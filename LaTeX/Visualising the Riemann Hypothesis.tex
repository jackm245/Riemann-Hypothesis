\documentclass{article}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage[utf8]{inputenc}
\usepackage{parskip}
\usepackage{listings}
\usepackage{color}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{multirow}
\usepackage[backend=biber, style=verbose]{biblatex}
\addbibresource{References.bib}
\usepackage{array}
\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{orange}{rgb}{0.82,0.6,0.4}
\definecolor{black}{rgb}{0,0,0}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  identifierstyle=\color{black},
  % numberstyle=\color{blue},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  escapeinside={(*@}{@*)}
}
\graphicspath{{./Media/Images}}
% \setcounter{secnumdepth}{4}

\author{Jack Morgan}
\title{Visualisation of the Riemann Hypothesis}

\begin{document}
\begin{titlepage}
    \begin{center}
    \vspace*{1cm}

    \Huge
    \textbf{An Investigation and Visualisation of the Riemann Hypothesis}

    \vspace{0.5cm}
    \LARGE
    \vspace{1.5cm}

    \textbf{Jack Morgan}

    \vfill

    A-Level Computer Science Coursework\\

    \vspace{2cm}

    \Large
    Dr Challoner's Grammar School\\
    Centre Number: 52205\\
    Candidate Number: 7469\\
    April 2022\\

    \vspace{1cm}

    \end{center}
\end{titlepage}

\tableofcontents

\clearpage

\section{Analysis}

\subsection{Introduction}

\subsubsection{Project Proposal}

Throughout this coursework, I will be examining the Riemann Hypothesis; to be able to visualise this important conjecture and make its complex mathematical structures accessible for anyone who is interested in mathematics. This project will be heavily based on how to compute and plot recursive mathematical functions on the complex plane and test whether the Riemann hypothesis is a true statement, as well as how the hypothesis affects mathematics today.

\subsubsection{Abstract}

During this coursework, I aim to be able to make the Riemann Hypothesis a more accessible mathematical concept to be able to help people to understand it and hopefully inspire them to research further into related mathematical subjects. I will do this in 3 simple ways:
\begin{enumerate}
\item By detailing what the Riemann hypothesis is and why it is so important,
\item Investigating the major functions that make up the Riemann Hypothesis
\item By Visualising the significant concepts of the Hypothesis, in order to make them more understandable; and to be able to investigate what they are and how they work.
\end{enumerate}

I will be conducting my investigation by programming the key functions of the Hypothesis in Python 3. This will allow me to:
\begin{enumerate}
    \item Compute key mathematical functions
    \item Plot graphs of data
    \item Store data in files and a database
    \item Have a graphical user interface
\end{enumerate}

\subsubsection{End Users}

This project is aimed at people who are interested in mathematics. It is a great way to inspire people to delve deeper into maths and number theory; as well as help those with a more advanced understanding of mathematics. Although the mathematics and understanding behind the problem can be complex at times, I am for this project to be able to be used by anyone who will want to use it. This would require it to be simple for people to understand and navigate. I aim to get input from people with a range of mathematical abilities to give me feedback on the project.


\subsection{Research}

\subsubsection{What is the Riemann Hypothesis?}

The Riemann Hypothesis - first proposed by Bernhard Riemann in 1859 - is considered by many to be one the most important unsolved problems in mathematics. To understand why the Riemann hypothesis is so important, it is necessary to understand what the Riemann hypothesis is, and how it is used in many mathematical and scientific fields.
The Riemann hypothesis was proposed by Bernhard Riemann in his paper "On the Number of Primes Less Than a Given Magnitude". This paper deeply explores the prime numbers, and the functions used to estimate and count prime numbers. Throughout this paper, Riemann discussed definitions and proofs of multiple theories that all relate to the prime numbers. But most notably, he had taken a function previously mentioned by Leonhard Euler (a famous mathematician who lived around 100 years prior), and formalised this function into the Riemann Zeta Function.


Riemann took Euler’s function and used a process called analytic continuation to extend the domain of this function to all numbers - be that real, imaginary or complex. Just like every other function, the Riemann Zeta Function contains what are called ‘zeros’ or ‘roots’. This is where a function’s output is equal to zero. These zeros can be described as trivial (where the explanation for why these zeros exist is almost intuitive), or non-trivial (where it can be hard to explain why these zeros occur.) The Riemann Zeta Function has trivial zeros when the input is a negative even integer. I will explore why this is the case later on.

\begin{wrapfigure}{r}{2.1in}
    \centering
    \includegraphics[width=2.0in]{critical-strip}
    \caption{Critical Strip and Line}
\end{wrapfigure}

However, the non-trivial zeros of the zeta function can be found when the real part of the function’s input is between 0 and 1 (called the critical region). This is a fact that has been proven by Riemann in his paper, and he even proved that there are an infinite amount of non-trivial zeros in the critical region. But Riemann went further than this, he hypothesised that the non-trivial zeros do not only occur when the real part of the input is between 0 and 1; but they all occur in the middle of the critical region when the real part of the input is exactly ½. The Riemann Hypothesis states that ‘the real part of every nontrivial zero of the Riemann zeta function is ½’. This is the fundamental part of the Riemann Hypothesis, and although it is widely considered to be true, this conjecture has never actually been proven with conclusive evidence, and that is why these are considered to be non-trivial zeros.


\subsubsection{The Importance of the Riemann Hypothesis}
The Riemann Hypothesis and the  Riemann Zeta Function have many extraordinary uses. From calculating prime numbers to uses in Quantum Physics, and even cryptography with the RSA algorithm. This is due to the fact that the Zeta function is deeply connected to the prime numbers.

One of the main reasons why the Riemann Hypothesis is significant is because there have been many conjectures and theories that assume the Riemann hypothesis to be true. So if the Riemann hypothesis was proven, this would also prove countless other theories.
Some of these theories include :
\begin{itemize}
    \item The weak Goldbach conjecture - stating that all integers greater than 5 are the sum of three primes
    \item Mills’ constants - numbers that allow you to generate prime numbers
    \item The theory that there will always be at least one prime between consecutive cubes
    \item The theory that there is a maximum bound between consecutive prime numbers
\end{itemize}
All of these theories are, in some way, related to the prime numbers. There is an important reason for this which I’ll cover in a later section.

If the Riemann Hypothesis was proven to be true, there would be profound effects in fields such as cryptography. In public-key cryptosystems, like RSA, public keys are created using prime numbers. If someone wanted to try and decode information without knowing what the prime numbers were that created the key, they would have to try and guess what the prime numbers were. What keeps these algorithms secure is the fact that it can take a long time to calculate the prime numbers, especially some of the larger ones. In fact, the largest prime number discovered has over 23 million digits. However, if the Riemann hypothesis were true, then people would be able to calculate the prime numbers much quicker than before. This would make many of the current cryptography algorithms obsolete.

The Riemann Hypothesis does not just influence mathematics and cryptography, it also has great importance in quantum physics. It was discovered in 1996 that the arrangement of the zeta zeros exhibits the same statistical pattern as the spectra of energy levels (that is the possible values of energy of a quantum system) in quantum chaotic systems. Furthermore, it was conjectured in 1999 by Michael Berry and Jonathan Keating, that there will exist a quantum system, where the energy levels will correspond exactly to the non-trivial zeros of the Riemann Zeta Function. If this conjecture is true, it would prove the Riemann Hypothesis.

\subsubsection{Complex Numbers and Key Operations}
Complex numbers play a key part in the Riemann Hypothesis. When Riemann created the Riemann Zeta Function, he allowed the inputs and outputs to be complex numbers, through his ideas of analytic continuation. It is therefore important to know what complex numbers are, and how to do arithmetic with them.

To first understand complex numbers (denoted by the symbol $\mathbb{C}$), it is necessary to be familiar with the idea of imaginary numbers. There is no real number whose square root is a negative number, so mathematicians decided to invent numbers for this. It is denoted by the symbol i, for the imaginary unit.

Where: $$i \equiv \sqrt{-1}$$
And thus: $$i^2 \equiv -1$$
You can multiply the imaginary unit($i$) by any real number to create an imaginary number. For example:
$$3i$$
$$2i$$
Which are both imaginary numbers.
By combining both real numbers and imaginary numbers, you can create complex numbers.
For example:
$$2+3i$$
Where the real part of the number is $2$, and the imaginary part is $3i$.
$$4-7i$$
Where the real part of the number is $4$, and the imaginary part is $-7i$.
We often represent real numbers on a number line, however, this is impossible to do with complex numbers. Instead, one way to understand them is through a two-dimensional graph, or to give it its formal name, the complex plane. On the complex plane, there are two axes, a real axis and an imaginary axis. Any complex number can be plotted on the complex plane. We can think of a complex number as a set of coordinates that tell us where the number lies on the complex plane, with the real part being the x coordinate and the imaginary part being the y coordinate.

So if we wanted to plot the point $2+3i$ on the complex plane, it would look as follows:

\clearpage
\begin{figure}[ht]
    \centering
    \includegraphics[scale=1]{argand diagram 23i}
    \caption{Argand Diagram of $2+3i$}
\end{figure}

This type of diagram is known as an Argand Diagram. And as you can see, we have plotted the point $2+3i$ at the coordinates $(2, 3)$ on the complex plane.

We can also do arithmetic with complex numbers - be that addition, subtraction, multiplication, division or exponentiation.

The sum of two complex numbers is the sum of both of the real parts of the numbers, plus the sum of the two complex parts of the numbers.
$$(3+2i) + (1+3i)$$
$$= (3+1) + (2i+3i)$$
$$= 4 + 5i$$

Subtraction is also done using a similar method.

$$(3+2i)-(1+3i)$$
$$=(3+2i) + (-1-3i)$$
$$=(3-1)+(2i-3i)$$
$$=2-i$$

To multiply two complex numbers, it is equivalent to expanding out two binomial brackets where:

$$(a+b)(c+d)$$
$$= ac + ad + bc + bd$$

So with two complex numbers this would look like:

$$(3+i)(2+2i)$$
$$= 6 + 6i + 2i + 2i^2$$
$$= 6 + 8i + 2i^2$$

We can then use the identity $i^2 \equiv -1$ to simplify this expression, so that:

$$= 6+8i + 2(-1)$$
$$= 4 + 8i$$

But we can speed up this method by using the rule $(a+bi)(c+di) = (ac-bd)+(ad + bc)i$
For example:
$$(3+i)(2+2i)$$
$$= (3\times2 - 1\times2) + (3\times2 + 1\times2)i$$
$$= 4+8i$$
We can derive this rule, to prove that it works for all complex numbers:
\begin{align*}
    RTP: (a+bi)(c+di) &= (ac-bd)+(ad+bc)i\\
    LHS &=  (a+bi)(c+di)
    \intertext{Distributing Terms:}\\
    &=ac + adi + bci + bdi^2\\
    \intertext{Using $i^2=-1$:}\\
    &=ac + adi + bci -bd\\
    \intertext{Then rearranging:}\\
    &= ac-bd + adi + bci\\
    &= (ac-bd)+(ad+bc)i\\
    &= RHS\\
    &\text{    }Q.E.D
\end{align*}

To divide two complex numbers, we create a fraction and then rationalise the denominator, by using the identity $(a+b)(a-b)  a^2-b^2$ where $a, b \in \mathbb{C}$ (meaning that a and b are both complex numbers)
For example:
\begin{align*}
    (3-i) &\div (2-2i)\\
    &=\frac{3-i}{2-2i}
    \intertext{We can then rationalise the denominator by multiplying the numerator and denominator of the fraction by $(2+2i)$. This does not change the value of the expression but does allow for it to be simplified.}
    &=\frac{3-i}{2-2i} \cdot \frac{2+2i}{2+2i}\\
    &=\frac{(3-i)(2+2i)}{(2-2i)(2+2i)}\\
    \intertext{We can then distribute terms in the numerator and denominator, using the aforementioned multiplication rule:}
    &=\frac{(6+2)+(6-2)i}{4-4i^2}\\
    &=\frac{8+4i}{4-4i^2}\\
    &=\frac{8+4i}{4-(-4)}\\
    &=\frac{8+4i}{8}\\
    &=1-\frac{1}{2}i\\
\end{align*}

There are also some functions that we can use on complex numbers to talk about the real and imaginary parts separately.
The $\Re(z)$ function (also defined as $Re(z)$), outputs the real part of the complex variable $z$. So for example:

\begin{align*}
    \intertext{If we let} z = a+ bi\\
    \intertext{Then} \Re(z) = a
\end{align*}

Similarly, the $\Im(z)$function (also defined as $Im(z)$) outputs the imaginary part of of the complex variable $z$.
For example:

\begin{align*}
    \intertext{If we let} z = a+ bi\\
    \intertext{Then} \Im(z) = b
\end{align*}

Although these functions have limited use in equations and mathematical usage, they prove very handy when needing to discuss complex variables. It is also very useful when computing functions, to be able to split up complex numbers into their real and imaginary parts.

We can also express imaginary numbers using the trigonometric functions, sine and cosine.

Where we have the complex number such that:

\begin{align*}
    z &= a+ bi\\
    \intertext{It can be expressed such that:}
    z &= r \cdot cis(\phi)\\
    \intertext{Where:}
    cis(\phi) &= cos(\phi) + i \cdot sin(\phi)\\
    r =|z| &= \sqrt{a^2+b^2}\\
    \phi =arg(z)&= arctan\left(\frac{b}{a}\right)\\
\end{align*}

This is known as the polar form of the complex number.

We can use this form to easily calculate the value when we raise a complex number to a real power, using De Moivre’s Theorem.
De Moivre’s theorem states that for a complex number in the form


\begin{align*}
    z &= r(cos ( \phi) + i sin ( \phi))\\
    \intertext{If we raise $z$ to the power $n$ then:}
    z^n &= (r(cos(\phi) + i sin(\phi)))^n\\
    &= r^n (cos(n\phi) + i sin(n\phi))
    \intertext{Which is true for}
    &r, \phi, n \in \mathbb{R}, z \in \mathbb{C}
\end{align*}

Which means that this formula does not work when we are raising any number to a complex power.

Say we have two complex numbers $z$ and $w$  and they are of the form $a+bi$. Such that $z=a+bi$ and $w=c+di$.To calculate $z^w$, the process is best split down into multiple steps.

First we calculate $\rho$ and $\theta$, where $\rho$ is the modulus of $z$ and $\theta$ the argument of $z$
\begin{align*}
    \rho &= \sqrt{a^2 + b^2}\\
    \theta &= \arctan{\frac{b}{a}}\\
    \intertext{Then using these values, we can say that:}
    z^w &= \rho^c e^{-d\theta}(\cos(d \ln \rho + c\theta) + i \sin(d \ln \rho + c\theta))\\
    \intertext{Which is true for}
    &z, w \in \mathbb{C}
\end{align*}


\subsubsection{The Riemann Zeta Function}

Previously I have mentioned multiple functions that play a key role in the Riemann Hypothesis, but now I aim to address and examine these functions in detail.

When discussing the Riemann Zeta Function the complex variable $s$ is traditionally used where $s =\sigma  + it$.

The Riemann Zeta Functions is defined as $\zeta(s)$ where:

\begin{align*}
    \zeta(s) &= \sum_{n=1}^{\infty} \frac{1}{n^s}\\
    &= \frac{1}{1^s} + \frac{1}{2^s} + \frac{1}{3^s} + \frac{1}{4^s} + \dots
\end{align*}

This was the equation that Leonhard Euler first introduced and studied, but it was Bernhard Riemann who defined this function for not just all of the real numbers, but all of the complex numbers. Riemann did this through the method of analytic continuation to expand the domain of the function. But by doing it he had to create a new function that would work for all possible input values. He produced what is known as Riemann's Functional Equation:

$$\zeta(s) = 2^s\pi^{s-1}sin\left(\frac{\pi s}{2}\right)\Gamma(1-s)\zeta(1-s) $$
Where $\Gamma(n)$ is the gamma function, such that:

$$\Gamma(n) = \int_{0}^{\infty}n^{s-1}e^{-n} \mathrm{d}n$$

From Riemann's Functional Equation, we can now see why the trivial zeros occur at even negative integers for $s$. This is all due to the sine function. If we let $s = -2n$ for $n \in \mathbb{N}$, (a negative even integer) then the functional equation becomes:

\begin{align*}
    \zeta(-2n) &= 2^{-2n}\pi^{-2n-1}sin\left(\frac{\pi(-2n)}{2}\right)\Gamma(1-(-2n))\zeta(1-(-2n))\\
    \Rightarrow \zeta(-2n) &= -2^{-2n}\pi^{-(2n+1)}sin(n \pi)\Gamma(2n+1)\zeta(2n+1)
\end{align*}
Now we can see that the functional equation includes a factor of $sin(n)$, but due to the nature of the sine function: $sin(n) = 0$ for $n \in  \mathbb{Z}$.  As shown in this diagram of the function $y = sin(x)$:

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{sinx-graph}
    \caption{$y=sin x$}
\end{figure}

And when the sine factor of the functional equation evaluates to zero, this causes the entire function to evaluate to zero, due to the fact that anything multiplied by zero, is zero. This suggests that when s is an even integer, the zeta function evaluates to zero. But then comes the question, why does the zeta function only have zeros at the negative even integers, but not the positive ones? Well, this is because of the gamma function ($\Gamma$).  The factor $\Gamma(1-s)$ in the functional equation has simple poles at positive integers, or in other words, when $s \in \mathbb{N}, \Gamma(1-s)$ is undefined. So for $s \in \mathbb{N}$, the sine function would evaluate to 0, but the gamma function would evaluate to an undefined value. These values cancel each other out, which means that the equation does not necessarily evaluate to $0$ if  $s \in \mathbb{N}$. This is why the trivial zeros are only found at negative even integers.

However, although Riemann’s Functional Equation has significant importance; it is long, complex, and would be hard to compute; mainly due to the fact that it is recursive, with the $\zeta(1-s)$ factor. Luckily, there are other equations that we can use to compute the Zeta function more efficiently.
An example of this is by using the Dirichlet eta function, denoted by $\eta(n)$, such that:


\begin{align*}
    \eta(s) &= \sum_{n=1}^{\infty}\frac{(-1)^{n-1}}{n^s}\\
    \intertext{This function is also known as the alternating zeta function. It has the special property that:}
    \eta(s) &= (1-2^{1-s})\cdot\zeta(s)\\
    \intertext{We can now do arithmetic and rearranging of this function so that we can use it to compute $\zeta(s)$.}
    \intertext{So rearranging for $\zeta(s)$:}
    \zeta(s)&=\frac{1}{1-2^{1-s}}\cdot \eta(s)
\end{align*}


\begin{align*}
    \intertext{Now, if we let $\phi_n = log(n)$, where $log(n)$ is the natural logarithm of $n$, then:}
    n^{it} &= e^{log\left(n^{it}\right)}\\
    &=e^{it\phi_n}\\
    &= cos(t \cdot \phi_n) + i sin(t \cdot \phi_n)
\end{align*}
Then if we express $\zeta(s)$ using $\eta(s)$ in its summation form, and split the variable $s$ into $\sigma+ it$, we derive that:

$$\zeta(\sigma + it) = \frac{2^{it}}{2^{it}-2^{1-\sigma}} \cdot \sum_{n=1}^{\infty} \frac{(-1)^{n-1}}{n^\sigma} \cdot \left[ cos(t\phi_n) -i sin(t\phi_n) \right]$$

Now, this equation is very long and complex, but it seems to be relatively simple to compute.
However, due to the fact that the Dirichlet eta function is only defined for values where the real part of sis greater than one, it means that this form of the zeta function is only defined when $\Re(s) > 0$.

Similarly, we can manipulate the earlier function to find it in another form that will be easy to compute as part of a program.
\begin{align*}
    \intertext{If we take the equation from earlier that:}
    \zeta(s)&=\frac{1}{1-2^{1-s}}\cdot \eta(s)\\
    \intertext{And substitute in the eta function where}
    \eta(s) &= \sum_{n=1}^{\infty}\frac{(-1)^{n-1}}{n^s}\\
    \intertext{Then we can say that}
    \zeta(s) &= \frac{1}{1-2^{1-s}}\sum_{n=1}^{\infty}\frac{(-1)^{n-1}}{n^s}
    \intertext{Then, by performing analytic continuation by using Hankel Functions (essentially very complicated mathematics that is beyond the scope of this project), it can be derived that:}
    \zeta(s) = \frac{1}{1-2^{1-s}} \sum_{n=0}^{\infty} & \frac{1}{2^{n+1}} \sum_{k=0}^{n} (-1)^k \binom{n}{k} (k+1)^{-s}
    \intertext{Where $\binom{n}{k}$ is a binomial coefficient where:}
    \binom{n}{k} &= \frac{n!}{k!(n-k)!}
\end{align*}

Just like the previous function we derived, this does look very complicated, however for a computer, it is relatively simple to compute.

\clearpage
\subsubsection{The Riemann Hypothesis and Prime Numbers}
The Riemann Hypothesis is deeply connected to the prime numbers. If the Riemann Hypothesis was proven to be true, then the effect this would have on mathematics would be monumental.


Leonhard Euler derived a very nice equation from the Riemann Zeta Function, that involves the prime numbers. This function is known as Euler's Product Formula.

We already know that the zeta function can be defined by:

\begin{align}
    \zeta(s) &= \sum_{n=1}^{\infty}\frac{1}{n^s} \nonumber
    \intertext{Where:}
    \zeta(s) &= \frac{1}{1^s} + \frac{1}{2^s} + \frac{1}{3^s} + \frac{1}{4^s} + \frac{1}{5^s} + \dots \label{1}
    \intertext{Now if we multiply both sides by the second term: $\frac{1}{2^s}$}
    \frac{1}{2^s} \cdot \zeta(s) &= \frac{1}{2^s} + \frac{1}{4^s} + \frac{1}{6^s} + \frac{1}{8^s} + \frac{1}{10^s} + \dots \label{2}
    \intertext{Subtracting equation \ref{2} from equation \ref{1} removes all elements with a factor of 2:}
    \left(1-\frac{1}{2^s}\right) \cdot \zeta(s) &= 1 + \frac{1}{3^s} + \frac{1}{5^s} + \frac{1}{7^s} + \frac{1}{9^s} + \dots \label{3}
    \intertext{Then multiplying again by the second term, $\frac{1}{3^s}$}
    \frac{1}{3^s}\left(1-\frac{1}{2^s}\right) \zeta(s) &= \frac{1}{3^s} + \frac{1}{9^s} + \frac{1}{15^s} + \frac{1}{21^s} + \frac{1}{27^s} + \dots \label{4}
    \intertext{Subtracting equation \ref{4} from equation \ref{3} removes all elements with a factor of 3 as well as those with a factor of 2 from the right-hand side.}
    \left(1-\frac{1}{3^s}\right)\left(1-\frac{1}{2^s}\right) \zeta(s) &= \frac{1}{5^s} + \frac{1}{7^s} + \frac{1}{11^s} + \frac{1}{13^s} + \frac{1}{17^s} + \dots \nonumber
    \intertext{We can see that the right-hand side of the equation is being sieved. If we repeat this process infinitely many times by multiplying by $\frac{1}{p^s}$where $p$ is a prime number, and then subtracting. We end up with:}
    \dots \left(1-\frac{1}{11^s}\right)\left(1-\frac{1}{7^s}\right)&\left(1-\frac{1}{5^s}\right)\left(1-\frac{1}{3^s}\right)\left(1-\frac{1}{2^s}\right) \zeta(s) = 1 \nonumber
    \intertext{Then rearranging for $\zeta(s)$:} \nonumber
\end{align}
$$\zeta(s) = \frac{1}{\left(1-\frac{1}{2^s}\right)\left(1-\frac{1}{3^s}\right)\left(1-\frac{1}{5^s}\right)\left(1-\frac{1}{7^s}\right)\left(1-\frac{1}{11^s}\right) \dots} $$
We can then write this as an infinite product over all primes, $p$:
$$\zeta(s)=\prod_{p, prime} \frac{1}{1-p^{-s}}$$
This function is only defined when $\Re(s) > 0$, due to the fact that negative numbers can not be prime. Furthermore, it would be hard to compute, due to the fact that you would be required to calculate the prime numbers first.

As well as Euler's Product Formula, there are many other functions that involve the prime numbers that are all related to the zeta function.

The prime number theorem was a theorem thought of by Carl Friedrich Gauss near the end of the 18th century. This theorem describes the distribution of the prime numbers. It formalises the intuitive idea that as numbers get larger, the prime numbers are less common, by precisely quantifying the rate at which this occurs. One way this theorem was modelled was through the prime counting function (denoted $\pi(N))$. Where $\pi(N)$ gives the number of primes that are less than or equal to $N$. Given this we can say that as $N \to \infty$ then $\frac{\pi(N)}{log(N)} \to 1$, where $log(N)$ is the natural logarithm of $N$
This, therefore, means that:
$$\pi(N) \sim \frac{N}{log(N)}$$
This means we can approximate the numbers of primes less than or equal to $N$, by calculating $\frac{N}{log(N)}$
For example, if we wanted to approximate the number of primes less than $100$:
Then our approximation would be:
$$\frac{100}{log(100)} = 22$$
But the true value:
$$\pi(100) = 25$$
So there is some error in our approximation.
However, the larger the number $N$, the better our approximation for $\pi(N)$.
For example:

\begin{align*}
    \pi(1,000,000) &= 50,847,534
    \intertext{and}
    \frac{1,000,000}{log(1,000,000)} &= 48,254,942
    \intertext{where proportionally, the error is a lot s      maller}
\end{align*}
However, Peter Dirichlet and Carl Friedrich Gauss came up this a much better approximation for $\pi(N)$. They said that:
$$\pi(N) \sim Li(N)$$
Where $Li(N)$ is the logarithmic integral of $N$ such that:
$$Li(N) = \int_0^N \frac{1}{log(t)} \mathrm{d}t$$
Where $\log(t)$ is the natural logarithm of $t$.
Now if we wanted to use the logarithmic integral function to approximate $\pi(1,000,000)$, we get that:
$$Li(1,000,000) = 50,849,234$$
Which is only $1700$ away from the true value.


As well as the prime counting function, we also have a similar function called the prime power function (denoted by $\Pi(N)$). In the prime counting function, you would get $1$ point per prime number (less than or equal to $N$). But in the prime power function, you get $1$ point per prime $+\frac{1}{2}$ point per prime squared $+ \frac{1}{3}$ point per prime cubed and so on.
As an equation this would be:

\begin{align*}
    \Pi(N) &= \pi(N) + \frac{1}{2}\pi(N^{\frac{1}{2}}) + \frac{1}{3}\pi(N^{\frac{1}{3}}) + \dots \\
           &= \sum_{r=1}^{\lfloor log_2  N\rfloor} \pi(N^{\frac{1}{r}})
\end{align*}

But how is this related to the Riemann Hypothesis? It turns out that the prime number theorem was proved by using the Riemann Zeta Function.

Riemann came up with a function for the Zeta Function where he described it in terms of the non-trivial zeros. He stated:

$$\zeta(s) = \left(\frac{\pi^{\frac{s}{2}}}{2\left(s-1\right)\Gamma\left(\frac{s}{2}-1\right)} \right ) \cdot \prod_{\rho}\left(1-\frac{1}{\rho}\right)$$

Where $\rho$ are the non-trivial zeros of the Riemann Zeta Function.

Then through complex analysis and advanced calculus, it was derived that:
$$\Pi(x) - Li(x) = \sum_{\rho}Li(N^\rho) - log(2) + \int_{N}^{\infty} \frac{1}{t(t^2-1)log(t)} \mathrm{d}t$$

Which tells us the difference or ‘error term’ between the prime counting function, and the prime power function. The main and most influential part of this error term is the sum of the logarithmic integrals of $N^\rho$.

Because $\rho$ are the non-trivial zeros, the non-trivial zeros of the Riemann Zeta function are really controlling the size of this error term. If the Riemann Hypothesis were true and all of the non-trivial zeros lie on the critical strip, then this error term will be as small as possible.

Mathematicians were finally able to prove the prime number theorem by using the Riemann zeta function, by showing that the Riemann zeta function has no zeros on the line $\Re(s) = 1$. However, this error term is controlled by the non-trivial zeros of the Riemann zeta function, and it is still unproven whether all of the non-trivial zeros lie on the critical strip. But if the Riemann Hypothesis were true, then this error term is bounded by:

$$|\pi(N) - Li(N)| \leq c \sqrt{N} \cdot log(N)$$

Where $c$ is some constant

This means that there would also be a similar bound between consecutive prime numbers, such that:

$$p_{n+1} - p_{n} \leq c \sqrt{P_{n}} \cdot log(p_{n})$$

There are also many other consequences if the Riemann Hypothesis was proved to be true. For example, the Weak Goldbach Conjecture would also be proven true, stating that ‘All odd integers greater than 5 are the sum of three primes’. Furthermore, if the Riemann Hypothesis was true then there will always be a prime number between consecutive cubes, such that:

$$x^3 < p < (x+1)^3$$

This would mean that you could define a constant $\theta$ such that $\lfloor \theta^{3^n} \rfloor$is prime for all n. This is called a Mills’ Constant.

All of these theorems and conjectures highlight the importance of the Riemann hypothesis, and that if it was to be proven, it would lead to several major breakthroughs, not only in mathematics but quantum physics and computer science. The fact that the non-trivial zeros of the Riemann zeta function have such an importance in countless other fields just shows how influential the Riemann Hypothesis is.

\subsubsection{Visualisations of the Riemann Hypothesis}

There are numerous ways of visualising functions on graphs and plots. Throughout this next section, I will explore the different types of data visualisation techniques, as well as their positives and negatives.


The most common form of visualisation for the Riemann Hypothesis is showing how the output of the Riemann zeta function varies as you move along the critical strip. It plots the values of $\zeta(s)$ for $s = \frac{1}{2} + it$, where $it$ is some imaginary number.


\begin{wrapfigure}{r}{2.2in}
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=2.0in]{Zeta-Polar-Graph}
    \caption{\\Polar Graph of the Riemann Zeta Function}
\end{wrapfigure}

This graph shows us how the Zeta function varies along the critical strip and allows for us to identify the non-trivial zeros of the function.

Whereas most graphs show the input to the function along a horizontal axis and the output along a vertical axis, we cannot do this with the plot of the Riemann Zeta function because we are required to use both axes to represent complex numbers on the complex plane.

Some positives about this graph are that it is simple and easy to understand. However, it would require an input value for $t$, which is not shown on the graph, for the data to have any practical use.

However, we can expand on this graph and use it to help us to create a dynamic graph. A dynamic graph is one that changes with time. To plot a dynamic graph of the Riemann Zeta function, we could plot values of $\zeta(s)$ along the critical strip so that $\zeta(s) = \frac{1}{2}+ it$. Where $t$ would be our independent variable.

However, we would be changing $t$ over time, where we would need a relationship between the time of the graph and $t$, which could be in the form of an equation.

If for example, we had it so that for every second, the value of $t$ increases by $1$, this would give us a dynamic graph that would plot the points of $\zeta(\frac{1}{2}+it)$ while the user is watching it. The graph would then be changing every second.

If we made it so that for every $0.1$ seconds then t increased by $0.1$, this would give us a much smoother plot and would be much more appealing to look at.

Although the graph at any given point in time would look the same as the previous graph, the fact that this graph is changing for the user to see makes it significantly more visually appealing. Furthermore, by changing the value of $t$ over time, it allows for the user to get a much deeper understanding of how the value of $t$ affects the values of the Riemann Zeta Function.

Another way of representing functions that involve complex numbers is through domain colouring. This technique for visualising complex functions assigns different colours to each point on the complex plane. Not only does domain colouring look very appealing and intriguing it is also very useful to be able to plot functions that require four dimensions.

\clearpage

\begin{wrapfigure}{r}{2.1in}
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=2.0in]{domain-colouring-plot}
    \caption{The Riemann Zeta Function Plotted Using Domain Colouring}
\end{wrapfigure}

To graph a function with real inputs and outputs, two dimensions are required: one for the input and one for the output. But complex numbers are made up of two variables (the real and imaginary parts) and therefore two dimensions.

This means that in order to plot both the input and output of a complex function it requires four dimensions. The simplest way of doing this is by using the method of domain colouring.

In order to represent a function by using domain colouring, it is necessary to determine how the colours of the graph will be chosen.

There are multiple ways of doing this, but one of the most common ways is by taking the output of the function and using this to determine the hue and saturation of the colour.

For example, if we had an argand diagram for the complex number $x+iy$:

\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.55]{argand-diagram}
    \caption{An argand diagram for the complex number $x+iy$}
\end{figure}

Then we could use the value of $\phi$ to determine the hue of the colour, and $r$ to determine the brightness of the colour.  If we did this for all outputs of a complex function, and then plotted them on a graph, then we would have a domain coloured graph.

Domain coloured graphs have multiple advantages: they look very interesting; they allow complex functions to be plotted using four dimensions; and they are useful to see the general trend of a complex function. However, these graphs are not ideal if you want to read off specific points.

Another method used to illustrate this data is through an interactive graph. An example of this could be where the user selects a complex number on the complex plane. This number is then input into the Riemann Zeta function and an animation is then displayed to show how that number gets translated by the Riemann Zeta Function. The graph would then display another data point that shows the output from the Riemann Zeta Function.

This type of graph is able to show the user how the Riemann Zeta function works and could even give insight into where the zeta zeros could be. Moreover, the interactive feature makes the graph a lot more engaging for the user.


We could also use interactive graphs to show how computers can approximate values for the Riemann Zeta function. Computers are unable to calculate the exact value of the output from the Riemann Zeta function, the reason of which I discuss later on, but it simply comes down to the fact that computers are unable to calculate the infinite series (where an infinite amount of numbers are added together) that are present in the functions. To get around this, you can compute these series to a high number that is not quite infinity, and still get a very accurate approximation.


\begin{wrapfigure}{l}{2.1in}
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=2.0in]{zeta-approximation}
    \caption{The approximation of $\zeta(2+3i)$}
\end{wrapfigure}

As each term in the series gets calculated, the approximation gets closer and closer to the true value. We can use this fact and display it on a graph. If a user selects a point on the complex plane, we can display the approximation for $\zeta(s)$ for $1$ term, $2$ terms ... all the way up until $n$ terms (where $n$ is a high enough number so that the approximation is extremely close to the true value). The resulting graph will show a spiral of data points that converge to one point; that is the output of the zeta function. This graph allows the user to understand how the infinite series works in the zeta function, as well as how computers are able to compute the zeta function.

\subsubsection{Data Storage}

As part of this program, I aim to be able to store the values of the $\zeta(s)$ for specific values of $s$. There are multiple ways to store data sets such as different file types and databases. I will be exploring these data storage methods and finding which method is best suited for my program.

The simplest way of storing data is by storing it in a text (.txt) file. These files store plain text that can be read from and written to. There is limited functionality when it comes to storing data in text files; as you can only read from and write to them. This could be used to store relatively simple and small amounts of data, but to store anything larger and more complex, text files won't be the best choice.

Another way of storing data is by using comma-separated values (CSV) files. These files consist of numerous records and fields, where each line is a record and the fields are separated by delimiters  - often commas.

\begin{wrapfigure}{l}{2.1in}
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=2.0in]{example-csv-file}
    \caption{An example CSV file}
\end{wrapfigure}

This type of storage for data has a lot more functionality than using plain text files. The use of field headers allows entire fields to be read or written to with ease and data can easily be sorted, grouped, and processed. However, some downsides of using the CSV data format are that only basic data can be stored. Complex tables and configurations cannot be used with CSV files. Furthermore, there is no distinction between text and numerical values which can make processing the data difficult.

 Undoubtedly, one of the most efficient ways of storing large data sets is by using databases. More specifically, by using Structured Query Language (SQL).

SQL is a declarative programming language, making it very efficient to use. Databases allow for large amounts of data to be written and read very quickly.

Moreover, processing this data can be very simple with packages such as SQLite that allows SQL databases to be accessed with Python. SQL databases are efficient and can store large amounts of data, making them ideal for a project like this.

\subsubsection{Programming Languages}

There are multiple programming languages that I could - relatively easily -  use for this project, but it is important to choose a language that is suited for the task at hand. Every language has its advantages and disadvantages. Throughout this section I will evaluate various languages and whether or not they would be suitable for this project. I will then give my overall verdict on which language I wish to use.

C++ is a fairly low-level compiled programming language. Its use of classes and memory manipulation allows for an extensive range of functionality. Furthermore, with countless libraries and support, there is almost no limit to what can be done in C++. This is one of the main benefits of this language, alongside the fact that it can run incredibly fast compared to some other interpreted languages, and that it can run on almost any machine. However, the actual coding in C++ is long and tedious. Especially for a project like mine where memory management is not too much of an issue, it seems unnecessary to have to code in C++.

Javascript is also another programming language that could be used for this project. Unlike C++, Javascript is used for more high-level projects, predominantly for web applications.  Making a web app has many advantages, such as high accessibility for multiple users. However, this would require an internet connection to run, and the speed of the program would be significantly reduced compared to that of a compiled application,

Python 3 is a high-level interpreted programming language, with a wide range of libraries and packages to support it. The main advantage of Python is that the code has high readability. This allows for it to be understood by people, even if they are not familiar with the language. Although Python is an interpreted language, there are ways to compile the code into an executable file that can be run on machines that do not have the interpreter installed. As well as this, Python has wide support for user interfaces and the plotting of graphs.

Overall, I think that Python 3 will be the programming language that is most suited for my project. A web application is not what my users are looking for, so javascript would be impractical to use. The high readability and high-level features are what makes Python the optimal programming language for this project, over Javascript and C++.

\subsubsection{Product Research}

Throughout this section, I will be taking a look at other programs that have similar features to mine. I will talk about the advantages and disadvantages of each program and how I can incorporate some of their features into my project.

\begin{wrapfigure}{r}{2in}
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=1.9in]{wolfram-alpha}
    \caption{Wolfram Alpha}
\end{wrapfigure}

One of the most major programs I will look at is the web application WolframAlpha. This is a mathematical computation site, where users can input a maths query into a search bar. The answer to the query is then returned, along with information about the solution.

In this example, I input zeta(10+5i). The program then outputs a decimal approximation of the answer to my query, as well as a diagram showing the output on the complex plane. Further down the page, the program lists alternative ways that I could’ve written my input.

This application works very well for calculating specific values of the zeta function, but it does little to show the mathematics of what’s happening to calculate the answer.
\clearpage
Another web application by Wolfram Research is the Riemann Zeta Function Page on Wolfram Mathworld.

\begin{wrapfigure}{l}{2in}
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=1.9in]{wolfram-mathworld}
    \caption{Wolfram Mathworld}
\end{wrapfigure}

This site explains the Riemann Hypothesis in great detail, giving the user a very thorough understanding of the subject. There are also multiple three-dimensional and domain coloured graphs that plot the Riemann Zeta Function. The user is able to change the scale of the plots to see how the zeta function changes, depending on the input. The web page contains a variety of different graphs and lots of maths along with explanations as to what is going on.

However, the maths on this page is very complex and it would be unlikely that people would understand this page if they didn't have some significant background knowledge into the Riemann Zeta function, or advanced maths in general. The page is also very linear starting from top to bottom. Overall, I like the way that the graphs are presented and explained here, however, the large quantity of maths displayed can seem confusing and unrelated.

\begin{wrapfigure}{l}{2.6in}
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=2.5in]{verifying-riemann-hypothesis}
    \caption{Verifying the Riemann Hypothesis by Aaron Meurer}
\end{wrapfigure}

The next program that I will look at is Verifying The Riemann hypothesis by Aaron Meurer.

He creates a program that finds the non-trivial zeros of the zeta function and displays this data on some very simple and understandable graphs. I like this program a lot because it contains a lot of relevant information.

Some positives of this program are that the graphs in it are presented and explained well so that anyone could understand what is going on. The only drawback is that this isn't a very extensive program. Only 2 graphs are calculated and there isn't a user interface.

Overall this program contains some appealing and useful information and graphs but could be more refined.
\clearpage
\subsection{Project Objectives}
My overall aim of this project is to be able to visualise and examine the Riemann Hypothesis, to make the complicated maths more accessible and to test whether the Hypothesis actually is true. I will be doing this by completing the following key objectives.
\begin{enumerate}
    \item The program will be interactive and engaging for the user
        \begin{enumerate}
            \item There will be various questions throughout the program that the user can answer
            \item The user will be able to make notes on any of the content in the program
            \item The user will be able to choose what they do and where they go in the program, not forced along a single route
            \item The user will be able to input their own values into various functions and graphs
        \end{enumerate}
    \item The user will be able to save their progress through the program via a login system
    \begin{enumerate}
        \item The login system should allow the user to:
        \begin{enumerate}
            \item Sign in to their account
            \item Create a new account
            \item Reset their password if they want to change it
            \item Reset their password if they have forgotten it
        \end{enumerate}
        \item Multiple users will be able to make separate accounts on the system
        \item The user's data such as passwords must be saved securely
        \item The user must be able to see how they have progressed throughout the program
    \end{enumerate}
    \item The user will be given some background information about the Riemann Hypothesis such that almost anyone could feel comfortable using the program
    \begin{enumerate}
        \item The user should be able to learn the historical background of the Riemann Hypothesis
        \item The user should be able to learn what imaginary and complex numbers are
        \item The user should be able to learn what the Riemann Hypothesis states
        \item The user should be able to learn about the practical applications of the Riemann Hypothesis
    \end{enumerate}
    \item The program will allow the user to plot various graphs in order to develop their understanding of the Riemann Zeta function and allow them to learn about it
    \begin{enumerate}
        \item A polar graph of the Riemann Zeta Function
        \item A graph of the prime counting function, and other related functions used to estimate it
        \item A graph of the zeroes of the Riemann Zeta Function
        \item A visualisation of the convergence of the infinite series in the Riemann Zeta Function
    \end{enumerate}
    \item The user will be able to calculate specific values of the Riemann Zeta Function
    \begin{enumerate}
        \item A single calculator, where the user inputs a complex input and receives an output
        \item A table calculator, where the user can calculate the zeta function for a range of input values
        \item A leaderboard showing how many values of the zeta function, each user has computed
        \item The program will allow the user to store these value(s) to a database and to a csv file
    \end{enumerate}
    \item The user will be able to calculate the zeroes of the Riemann Zeta Function
    \begin{enumerate}
        \item The user will input how many zeroes they want to calculate
        \item The program will calculate these zeroes
        \item The zeroes will be displayed to the user in a table
    \end{enumerate}
    \item The user will be able to store the data that they have collected
    \begin{enumerate}
        \item The program will include a database of multiple values and zeroes of the zeta function
        \begin{enumerate}
            \item The user will be able to store values of the zeta function
            \item The user will be able to store the non-trivial zeta zeros
            \item The user program will retrieve data from the database and display its contents suitably to the user
        \end{enumerate}
    \end{enumerate}
    \item The Program will have a graphical user interface
\end{enumerate}
\clearpage
\subsection{Third-Party Input}

Throughout the following section, I will be discussing the consultation and guidance that I have received from various third parties. This section will cover the significance of third party input, who my third parties are, how and why I will be conducting my research, a transcript of the actual interviews themselves and my conclusions and takeaways from them.

\subsubsection{The Significance of Third Party Input}
Collecting third party input is vital in creating a successful project. It will allow me to assess the progress that I have made so far in my project, and check that I am heading in the right direction. Having input from various different people allows for people to view the project in different ways, each giving their own advice towards it. Third-party input and feedback is extremely important because it can help me develop and improve my project.

\subsubsection{Who are my Third Parties?}
There are benefits and drawbacks to each person you have as a third party. These depend on their relationship with me, their experience with creating projects like these and their willingness to help; just to name a few factors.

For my third parties, I am using friends who are computer science and further maths students. The benefits of this are that they have good availability, and I can talk to them regularly about the project. Furthermore, they are very supportive and encouraging. Because they are further maths and computer science students, they are also very knowledgeable about the subject area. However, the drawbacks of having friends as third parties are that they are potentially biased towards my project and could be unwilling to criticise it. It could be hard for them to tell me what is wrong, or what could be improved.

\subsubsection{How and Why I will be Conducting My Research}
I will be conducting my third party research by conducting interviews with my third parties. By creating a list of questions, I am able to ask specific questions that are useful to me. I have tailored the questions such that I can use the answers to help improve my project.

The interviews start with me asking questions to the third parties and taking answers from them. At the end of the interview, the third parties have an opportunity to ask me any questions that they have about the project.

\subsubsection{Interview Transcript - Student 1}

\textbf{Question: What will an end-user be able to gain from using this project, how would it be helpful to them?}

Answer: As a maths and further maths student, I want to be able to extend my knowledge of these subjects. This project looks like a good resource that will allow someone to understand the Riemann Hypothesis.

\textbf{Question: What features could be implemented into the project such that the end-users can accomplish what was mentioned in the previous question?}

Answer: It would be very beneficial to the user to have an explanation of the theory behind the Riemann Hypothesis at the beginning of the program. I'd like to do a couple of example steps, so I can try and understand the program before I start using it. You could have an example graph and pause the graphing animation and explain at each point what is happening. As well as this, I would like the program to be interactive so that I can really control what is happening.

\textbf{Question: How accessible would this project be for someone with little or no knowledge of the subject area?}

Answer: Due to the nature of the project, it is not extremely accessible. However, for someone with an interest in mathematics, they may be more willing to research around the topic to gain an understanding

\textbf{Question: What could be done such that people who have less experience with the subject matter are still able to understand the program? How could it still be relevant to them?}

Answer: For people with less experience, you could add some of the background information and story about the Riemann Hypothesis and the investigation. Mention why it's so important, and how it came to be. Not just the maths but the history behind it.

\textbf{Question: Which parts of the project interest you; what would you like to research further?}

Answer: The links to cryptography interest me. The fact it’s such a modern-day feature of life, actually using the function that was theorised so long ago. I am interested in the practical applications of the Riemann Hypothesis and how it actually relates to me.

\textbf{Question: How would someone be able to use this project to extend their knowledge of this subject area?}

Answer: You would be able to use the interactive interface to manipulate and break down the theory of the hypothesis, in order to gain a deeper understanding of it

\textbf{Question: Which features of the project do you like, and why?}

Answer: Visualising is helpful for exploring the project. I like the graphs, the fact it has a visual element is very appealing. It is easier to appreciate the graphs than just looking at mathematical equations.

\textbf{Question: Which features of the project do you think could be improved?}

Answer: The accessibility to the project could be improved; in terms of the mathematics knowledge needed to understand it as well as how the program can be physically accessed and run. For example, as a downloaded piece of software or as a web application.

\textbf{Question: Have you used any similar programs to this? What were they like?}

Answer: A program that seems similar to this that I have used is the practical investigation software Focus eLearning. I used this to carry out practical investigations and consolidate learning. I liked that it was accessible over the internet and that it gave me explanations of the theory, with a visual exploration of the theory it was trying to explain, in the form of the interactive practical experiment. However, I felt that the user interface was difficult to navigate.

\textbf{The question they asked me: How will you refine the access of the project so that everyone can use it?}

My answer: I will include a detailed description and explanation of the Riemann Hypothesis as part of the program to make sure that whatever your mathematical ability, you will still be able to use the program.

\subsubsection{Interview Transcript - Student 2}

\textbf{Question: What will an end-user be able to gain from using this project, how would it be helpful to them?}

Answer: The Riemann Hypothesis itself is used in so many areas such as in cryptography and quantum physics, talking about the practical uses of the hypothesis would be helpful for the user to gain an insight into why the hypothesis is so important.  I am interested in the practical usage of theory in computing and physics. Being able to understand the Riemann Hypothesis visually is also very helpful. Being able to graphically plot the many functions will give a deeper understanding of the project. Furthermore, being able to change the input values to the functions would help so that the user can expand their knowledge of the function

\textbf{Question: What features could be implemented into the project such that the end-users can accomplish what was mentioned in the previous question?}

Answer: It would be very good to make the graphing program interactive. This can be done by changing the function’s input values, but also being able to traverse the plot by scrolling around and zooming in and out by changing the scale. It would also be useful to have multiple graphs displayed on the same set of axes to compare values.

Following along with this interactive idea, I think that you could questions for the user to answer about the hypothesis, to help solidify their understanding of it. It could be beneficial to add sections where the user and write down their observations and any conclusions that they have drawn from the investigation.

To implement this, you could create a login system where a user creates a username and password, so that they would be able to save their progress in the program.

\textbf{Question: How accessible would this project be for someone with little or no knowledge of the subject area?}

Answer: I believe this project will be relatively accessible because it mainly involves just displaying maths functions, where it takes an input and gives an output. It's relatively easy for someone to use it without knowing the details of how it works. That is, to be able to use the program, but maybe not fully understand it. But then to get a deeper understanding of the project, it takes more in-depth knowledge.

\textbf{Question: What could be done such that people who have less experience with the subject matter are still able to understand the program? How could it still be relevant to them?}

Answer: Start off by just exploring and explaining the hypothesis, how it works and how the Riemann zeta function works. If the user wants to understand it further, you can go through the maths of how it works; explaining the Riemann Hypothesis in detail. You could graph the individual mathematical functions in order to break down the problem for the user to understand.  You can use 3D graphs and different ways of representing the data. This could make it easier for the user to understand.

\textbf{Question: Which parts of the project interest you; what would you like to research further?}

Answer: I am very interested in the cryptography application of the Riemann hypothesis. You could showcase as part of this project, a cryptography program that utilises the Riemann hypothesis in a practical way.

\textbf{Question: How would someone be able to use this project to extend their knowledge of this subject area?}

Answer: By utilising the multiple mathematical functions of the Riemann Hypothesis, the user could investigate how changing the input values changes the output. This will help the user learn about the individual functions and their use cases. When combining these functions together, it is important for you to be able to show how changing one piece of data can entirely change the output of a function, especially if the functions are all linked together. You should create the program such that the users could use it to investigate the domains and ranges of the functions.

\textbf{Question: Which features of the project do you like, and why?}

Answer: I like the idea of having an introduction where you explain the practical uses of the Riemann Hypothesis, and where you can give an explanation of how to use the Riemann Hypothesis and Riemann Zeta Function in other programs such as in the RSA cryptosystem. I like how the user would be able to change and manipulate the graphs to their liking and how easy it is to compare values of separate functions. It’s also a good idea to have a  conclusion/summary to help the user fully understand the maths.

\textbf{Question: Which features of the project do you think could be improved?}

Answer: It would be good for the user to be able to draw their own custom graph functions on the same axes as the functions in the program because currently, you would not be able to compare the functions in the program to the user’s own custom functions. A drawback of the project is that the maths could be too specific and intricate for the user to gain a proper understanding of the project. It would require a lot of research to fully understand the project and to be able to make the most of it.

\textbf{Question: Have you used any similar programs to this? What were they like?}

Answer: A program like this that I have used is desmos. Desmos, a graphing software, allows you to plot many graphs on top of each other, you can easily change the axes as well as any input values. What’s bad about desmos is that it doesn’t allow you to plot in 3D, it would be nice to see this in your project. Another program similar to this is Graphing Calculator 3D.
This allows you to do what desmos does, but it plots in 3D. However, its downsides are that It’s not very user friendly and the menus are not easy to navigate, so it can be hard for new users to understand how the software works.

\textbf{Questions asked to me:}

\textbf{Question: What are the necessary system requirements?}

Answer: The necessary system requirements for this program are not very high. The functions are very memory and time efficient so the specifications of the systems that the program is run on should not be an issue.

\textbf{Question: What would help the software be more useful to the user?}

Answer: If that program gave an in-depth explanation of the Riemann Hypothesis, the user can gain a full understanding of what is going on. Furthermore, examples of the practical applications of the Riemann Hypothesis, make the program more relevant to the user and makes this program practical use instead of just being theory.

\textbf{Question: With such complicated functions, how long would it take to compute them?}

Answer: The functions I have written are very memory and time-efficient, it will not take an extensive amount of time to compute the required mathematical functions.

\textbf{Question: To what degree of accuracy will the functions be plotted?}

Answer: The user will have an option where they can increase or decrease the accuracy of the functions. However, this will come with the disadvantage that it will take longer to compute.

\subsubsection{Interview Conclusion}
There are multiple improvement points from these interviews that I have used to help develop the plan for my project.

One of my main improvement points is with the design and layout of the project. The program will have 3 main sections: the introduction, the investigation, and the summary.

The introduction section will let the user be able to read and learn about the Riemann Hypothesis, so they can get an understanding of it, before using the main program. This introduction aims at making the program more accessible to people, even if they have less experience with maths. It will also allow people to explore the Riemann Hypothesis’ links to cryptography and other practical applications so that they can explore it in more detail.

After the introduction will be the actual practical investigation, this is where the user can plot graphs and really investigate the Riemann Hypothesis. They will be able to plot multiple graphs on the same axes in order to be able to compare values. The user will also be able to easily change the input values to many of these graphs so that they can investigate how this changes the outputs.

The final part of the program will be a summary; showcasing the results from the investigation that they have conducted, and detailing some of the key mathematics behind the investigation.

Breaking down the project into these three sections will allow for the User Interface of the program to be simple, such that the user can access all of the relevant parts of the program easily.

Another part of the project spoken about in these interviews was a login system to help save a user's progress through the program. There would be multiple points in the program where the user can answer questions about the hypothesis to check understanding, or for the user to just write down any conclusions that they make about the investigation and the Riemann Hypothesis. Thus, creating a login system would allow a user to save their progress in the program, and any of their answers and data can be stored in a database.
\clearpage
\subsection{Modelling the Problem}
In this section, I will report any modelling of my project that will inform the design stage. I will be covering how to compute certain mathematical functions and also try some prototypes for what the project will look like.

\subsubsection{Prototypes}

Throughout this next section, I will be prototyping some mathematical functions in Python that will allow me to compute the Zeta Function. I will then test each of the functions to make sure that they work as expected.

The majority of functions that I intend to use involve an infinite sum, which is something that we are unable to compute because it would be impossible to add up an infinite amount of numbers. Therefore we must approximate the value of the function by calculating it for a certain number of terms. For example, when calculating the zeta function where:

$$\zeta(s) = \sum_{n=1}^{\infty} n^{-s}$$

We can approximate the value but calculating the sum to such a high number, that the error difference is not significant. If we want to approximate the zeta function, we could compute:

$$\zeta(s) = \sum_{n=1}^{1 \times 10^6} n^{-s}$$

Which would not give us the exact value, but one close enough that we can still use.

First of all, is a function that computes the zeta function by its definition. $\zeta(s) = \sum_{n=1}^{\infty} n^{-s}$. This function is defined for $\Re(s) > 1$ and could look as follows in Python 3:

\begin{lstlisting}
# calculates zeta(s) for any complex number where Re(s) > 1
# where \zeta(s)=\sum _{n=0}^{\infty }\frac{1}{n^s}
def zeta(s: complex) -> complex:
    TERMS = 5 * 10**3 # the number of terms that we wish to compute.
    result = 0
    # computes an approximation for the infinite sum
    for n in range(1, TERMS+1):
        result += 1/(n**s)
    # output the final result
    return result
\end{lstlisting}

First, we define the function \textit{zeta(s)}, where \textit{s} is a complex variable. Then the constant \textit{TERMS} is defined then defined to be a large integer. This number determines how many times we calculate $\frac{1}{n^s}$ and therefore determines how accurate our approximation will be. Then in the for loop, we calculate $n^{-s}$ for \textit{TERMS} many times and sum it to our result. We then return the complex variable res in order to output from the function.

Here we can test the function to show if and when it works as expected, and also how accurate it is to the true value.
\\
\begin{table}[ht]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \textbf{No.} & \textbf{Type} & \textbf{Input} & \textbf{Expected Output} & \textbf{Output} & \textbf{Result}\\
    \hline
    \hline
    1 & Invalid & -1 & ValueError & 12502500.0 & Fail\\
    \hline
    \multicolumn{2}{|c|}{Comment} & \multicolumn{4}{|c|}{This output is neither the output we were expecting}\\
    \multicolumn{2}{|c|}{} & \multicolumn{4}{|c|}{nor the correct output of $\zeta(-1)$. I will need to fix}\\
    \multicolumn{2}{|c|}{} & \multicolumn{4}{|c|}{this by validating the input to check that it is}\\
    \multicolumn{2}{|c|}{} & \multicolumn{4}{|c|}{within the defined range of the function}\\
    \hline
    \hline
    2 & Invalid & 0 & ValueError & 5000.0 & Fail\\
    \hline
    \multicolumn{2}{|c|}{Comment} & \multicolumn{4}{|c|}{This is the same situation as test number 1}\\
    \hline
    \hline
    3 & Boundary & 1 & ValueError & 9.095 & Fail\\
    \hline
    \multicolumn{2}{|c|}{Comment} & \multicolumn{4}{|c|}{This is the same situation as the previous tests}\\
    \hline
    \hline
    4 & Valid & 1.5 & 2.61 & 2.584 & Fail\\
    \hline
    \multicolumn{2}{|c|}{Comment} & \multicolumn{4}{|c|}{Although this gives an output that is close to the}\\
    \multicolumn{2}{|c|}{} & \multicolumn{4}{|c|}{expected output, it is not accurate enough. I need}\\
    \multicolumn{2}{|c|}{} & \multicolumn{4}{|c|}{to increase the number of terms in order to get a}\\
    \multicolumn{2}{|c|}{} & \multicolumn{4}{|c|}{more accurate output}\\
    \hline
    \hline
    5 & Valid & $5$ & $1.025$ & $1.025$ & Pass\\
      & & $+10i$ & $-0.015i$ & $-0.015i$  & \\
    \hline
    \multicolumn{2}{|c|}{Comment} & \multicolumn{4}{|c|}{This test gives a value that is extremely close to the}\\
    \multicolumn{2}{|c|}{} & \multicolumn{4}{|c|}{true value. It see,s that out approximation becomes}\\
    \multicolumn{2}{|c|}{} & \multicolumn{4}{|c|}{more accurate as the input value increases.}\\
    \hline
    \end{tabular}
\end{table}
\clearpage
Based on the testing, I have made some adjustments to the function as seen here:

\begin{lstlisting}
# calculates zeta(s) for any complex number where Re(s) > 1
# where \zeta(s)=\sum _{n=0}^{\infty }\frac{1}{n^s}
def zeta(s: complex) -> complex:
    # validate that Re(s) > 1
    if not s.real > 1:
        raise ValueError('Real part of input must be greater than 1')
    TERMS = 1 * 10**6 # the number of terms that we wish to compute.
    result = 0
    # computes an approximation for the infinite sum
    for n in range(1, TERMS+1):
        result += 1/(n**s)
    # output the final result
    return result
\end{lstlisting}

The first change I made was validating the input. Now if the real part of the input is less than $1$, then a \textit{ValueError} is raised. Secondly, I have increased the number of \textit{TERMS} that are computed in order to make the program more accurate. Although this does make the program take more time, the time difference is hardly noticeable.

Now here are the testing results for the improved function.

\begin{table}[ht]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
    \textbf{No.} & \textbf{Type} & \textbf{Input} & \textbf{Expected Output} & \textbf{Output} & \textbf{Result}\\
    \hline
    \hline
    1 & Invalid & -1 & ValueError & ValueError & Pass\\
    \hline
    \multicolumn{2}{|c|}{Comment} & \multicolumn{4}{|c|}{This works as expected; the error is raised}\\
    \hline
    \hline
    2 & Invalid & 0 & ValueError & ValueError & Pass\\
    \hline
    \multicolumn{2}{|c|}{Comment} & \multicolumn{4}{|c|}{This works as expected; the error is raised}\\
    \hline
    \hline
    3 & Boundary & 1 & ValueError & ValueError & Pass\\
    \hline
    \multicolumn{2}{|c|}{Comment} & \multicolumn{4}{|c|}{This works as expected; the error is raised}\\
    \hline
    \hline
    4 & Valid & 1.5 & 2.61 & 2.61 & Pass\\
    \hline
    \multicolumn{2}{|c|}{Comment} & \multicolumn{4}{|c|}{This functions output is very close to the true value}\\
    \hline
    \hline
    5 & Valid & $5$ & $1.025$ & $1.025$ & Pass\\
      & & $+10i$ & $-0.015i$ & $-0.015i$  & \\
    \hline
    \multicolumn{2}{|c|}{Comment} & \multicolumn{4}{|c|}{This functions output is very close to the true value}\\
    \hline
    \end{tabular}
\end{table}

Overall, this function is able to compute values of $\zeta(s)$ where $\Re(s) > 1$. It throws an error at incorrect inputs (which is good) and calculates $\zeta(s)$ relatively accurately. However, this approximation could be made more accurate by increasing the number of \textit{TERMS}, although this could slow the program down significantly. Using this function to calculate $\zeta(s)$ to any useful degree of accuracy would take too much time to compute. Furthermore, this function only allows us to calculate values where $\Re(s) > 1$.

\clearpage
\section{Documented Design}

\subsection{Structure Diagrams}

The program will be made up of 4 main parts; that is the Login System, the Introduction, the Investigation, and the Summary.

The login system will allow users to either sign into an account or create an account with a username and password. All user information will be encrypted using hashing algorithms for security reasons, and the data will be stored in a database. The purpose of the login system is to allow the users to save their progress throughout the program. There will be various opportunities throughout the program for the user to write down answers to questions, or to record any observations that they make. This data will be stored specifically to their username such that when they next log in, they can continue from where they left off.

The introduction will be a visual section of the project that will demonstrate to the user how the program will work, as well as give an overview of what the riemann hypothesis is, why it's important, and how it is used in science and technology. The aim of this section is to provide the user with sufficient information and knowledge such that they will be able to effectively be able to use this program. Because quite a lot of mathematical knowledge is required to be able to properly use this program to its full potential, this section will try and provide some basic information of the project area for the user to feel more comfortable using the program.

The investigation will be the main bulk of the program. It will allow the user to plot graphs, find zeta zeros using a variety of methods, and investigate how prime numbers are related to the zeta function. The aim of this section is to get the user to investigate the hypothesis, collecting their own data that they can draw conclusions from.

Finally, the summary will be the last section of the program. Its purpose is to allow the user to reflect on their results, and see what conclusions they are able to draw from them. The summary will be split into 4 sections; a quick recap of the theory from the introduction section; followed by an overview of the user’s results from the investigation. There will then be sections on whether their data proves/ disproves the Riemann hypothesis, how reliable the information from this program will be, and the impact on maths and computer science if the hypothesis is proven to be true.
\clearpage
\subsubsection{Program Overview Structure Diagram}
The following structure diagram for the program gives an overview of the main sections in the project:

\begin{figure}[ht]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.095]{program-structure-hierarchy-diagram}
    \caption{Structure Diagram for the program}
\end{figure}

As we can see from this diagram; the main program is split up into its 5 main sections: the Login System, the Tutorial, the Introduction, Investigation, and the Summary. Each of these main sections is then further broken down into its relevant subsections.

We can then break down each section into its subsections, which will in turn, be broken down into more sections.
\clearpage
\subsubsection{Login System Structure Diagram}

The login system's aim is to be able to allow a user to sign into an account, such that their progress with the program has been kept.

It will not be necessary for a user to login, however, if they do not log in, then their progress will not be saved.

\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.45]{login-system-structure-diagram}
    \caption{Login System Structure Diagram}
\end{figure}

There will be 5 sections to the login system that I create. The first of which allows the user to sign up and create an account. This is for first-time users of the programme, who want to be able to use it to its full functionality. The sign up process involves the user creating a unique username, adding a unique email to the account (used for when the user forgets their password), and creating a strong and complicated password. They will then be sent an email to the address that they entered, with a verification code. Once this code has been entered in the program, the user's login details will be encrypted and stored in a database. They will then advance to the next part of the program: the tutorial.

The login section will allow the user to sign in to an account that has already been created. They will be required to enter either their username or email, and their password. The program will check whether the username or email is valid (if it is in the database), and if the password associated to that account is the same as the one entered by the user. If the user gets the password wrong 3 times, then they will have to wait 1 minute before trying again. This is to stop any attacks to try and guess user's passwords. Once a user has signed in, they will be taken to the tutorial section.

If a user has forgotten their password, then they will be able to reset it in the forgotten password section. The user will be required to enter either their username and email for that account. These credentials will need to be verified, and then if they are correct, a new password will be sent to the user by email.The user will then be sent straight to the Reset Password screen so that they can change the password to one that they will remember.

The reset password section will allow the user to change their password if they don't like the one they currently have, or if they have had to reset their password. They will have to enter their username and password, to confirm their identity. They will then enter a new strong and complicated password, and this will be the new password associated to their account.

The final section is the continue without login section. Without a login, the user will still be able to use all parts of the program, however, their data will not be saved.

\subsubsection{Tutorial Structure Diagram}

The tutorial is one of the key sections of the program. The tutorial will give the user a guide on how to use the program.

\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.55]{tutorial-structure-diagram}
    \caption{Tutorial Structure Diagram}
\end{figure}

The tutorial itself will be split up into 4 main parts; that is a guide on the structure of the program, and how to use each of the individual sections of the program.

Overall, the tutorial will be relatively simple, and will just give the user an understanding of how to use the program

The Program Structure Guide will inform the user of the layout of the project, and how each section is related to another. It will tell the user how to navigate pages, and how to use key features of the program that will require user input.

Next in the tutorial, will be the Login Guide. This will essentially just be a quick note to the user, about how to sign up and create a strong and complicated password, what to do if you forget your password, or want to change it; as well as explain why the user may or may not want to create an account, and how the program differs whether the user is signed in or not.

As for the Introduction Guide, it will show an example of what the introduction section will look like, and have labels to show how to navigate pages as well as what everything means.

Probably the most complex part of the tutorial section will be the Investigation section. This will inform the user of how to use, understand, and interpret the different graphs and plots. This section should give the user a simple understanding of how they can use the program to investigate the Riemann Hypothesis

The final section in the tutorial will be a Summary Guide, that is how to use the summary section of the program. This will be very similar to the Introduction Guide, but will have an emphasis on the user trying to draw conclusions from the data they have collected, instead of the just being able to understand what is going on.

The tutorial section will not have a lot of functionality, but its purpose is just to briefly describe to the user, how the program is intended to be used.

\clearpage

\subsubsection{Introduction Structure Diagram}
In the Introduction section of the program, the user will be able to develop their understanding of what the Riemann Hypothesis is and why its so important.

I will portray this information by splitting the Introduction into three smaller sections. You can see how this section will be split up in the Structure Diagram below:

\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.385]{introduction-structure-diagram}
    \caption{Introduction Structure Diagram}
\end{figure}

First of all is the historical background section. This shows how the Riemann Hypothesis has developed over time and showcases the context of the problem

Next is the section describing the Riemann Hypothesis. This section will include a lot of maths, but will also be written such that people will a limited mathematical understanding will still be able to understand what is being said.

The final part of the introduction is the Practical Applications section. This will inform the user why the Riemann Hypothesis affects us today and how it can actually be used.

\clearpage
\subsubsection{Investigation Structure Diagram}
The Investigation is the main part of the program and will allow the user to conduct their own research into the Riemann Hypothesis.

It will have 4 main section; The graphs, Prime Numbers, a zeta function calculator, and a zeta zeros calculator.

\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.5]{investigation-structure-diagram}
    \caption{Investigation Structure Diagram}
\end{figure}

The first section will be the Graph Plot section. The aim of this section is to display to the user various graph plots that are related to the zeta function. This user will be able to change given inputs into the graph plots and be able to see the output visually.

The prime number section will show the user the correlation between the Riemann Zeta Function and the prime numbers. This section will showcase various graphs and mathematical functions for the user to explore.

Next is the zeta function calculator. This will be a relatively simple part of the investigation section. It will allow the user to input a number (or range of numbers)into the calculator. It then calculates these values and will allow the user to store the data, either in a file or database.

Finally is the zeta zeroes calculator. This will calculate all of the zeta zeroes between two points given by the user, and with accuracy determined by the user. Similarly to the zeta function calculator, the user will also be able to store this data to a database or file, or even display the data in a graph plot.


\subsubsection{Summary Structure Diagram}

The final main section in the program will be the summary. It will be a recap of what the user should have learnt from using the program, and what to take away from it. It will be split up into a theory recap section, a results section, a conclusion and evaluation section and a section on the impact of the Riemann Hypothesis.


\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.5]{summary-structure-diagram}
    \caption{Summary Structure Diagram}
\end{figure}

The first part of the summary; the theory recap will essentially be a very cut down version of the introduction section. It will provide an overview of the problem such that the user can refresh their mind as to what the Riemann Hypothesis actually is.

As for the investigation results, this page aims to provide the results of the user's investigation. It will provide raw data as well as some visual aids such as graphs. It will also compare the data collected by the user with the expected data.

Next is the conclusion and evaluation section. This section will detail to the user how accurate their results were to the true values, as well as any evidence and proof of the Riemann Hypothesis.

Finally, is the Impact of the Riemann Hypothesis. The aim of this section is to explain to the user why the Riemann Hypothesis is so important by explaining how it affects us.


Overall, I feel as if I have sufficiently broken down my project into a number of more manageable parts that will comes together neatly to form the whole system.
% \subsection{Hierarchy Diagrams}

% \subsection{System Flowcharts}

% \subsection{Data Flow Diagrams}

\clearpage
\subsection{Object-Oriented Design}

% $$NEED TO ADD UI CLASSES$$

% $$ AND ALSO EXPLAIN HIGH LEVEL OOP STUFF$$

% $$SEE BOOK ON HOW TO DO PROPERLY$$

\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.6]{number-systems-class-diagram}
    \caption{Number Systems Class Diagram}
\end{figure}
As part of this project I will need to be able to represent many types of numbers namely, fractions and complex numbers. The best way to do this is to use Classes and Object-Oriented Programming. I can create a data structure in python, such that they will be able to store all of the necessary data, and perform all the operations that I need.

All of the data types will inherit attributes and methods from a main \textit{‘Number’} Class. This number class will have basic attributes and methods, allowing a number to be defined and printed.

The complex number class is a lot more substantial than the number class.  It will allow for inputs in Rect form, or Modulus Argument Form. The methods in this class will allow for the user to add, subtract, multiply, divide, and use exponentials with complex numbers. There will also be a set of private functions in the class in order to change between cartesian and polar form.

As for the fraction class, it will take inputs of a numerator and denominator, and will allow the user to use public functions in order to perform operations and calculations involving fractions.

These classes will be able to let me sufficiently perform precise calculations with numbers. The fraction class removes any mathematical floating point errors from calculations, and the complex class will allow me to utilise imaginary and complex numbers in Python.

Some points to note; I have tailored this class diagram and the following pseudocode for a Python programme. Conventionally, when calling a function prefix notation is used. For example, if we have a simple function as follows:

\begin{algorithm}
    \caption{Prefix add function}
    \begin{algorithmic}
        \Function{add}{$a$, $b$}\\
             \hspace{\algorithmicindent}\Return $a + b$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

Then we can see that it takes two inputs, a and b, and will return their sum.

To call this function, we will use prefix, notation with the function name at the beginning, followed by the two parameters.
Such as:

\begin{algorithm}
    \caption{Calling the prefix add function}
    \begin{algorithmic}
       \State \Call{add}{$a$, $b$}
    \end{algorithmic}
\end{algorithm}

However, in Python, we are able to create mathematical functions that allow for infix notation. This is a more natural way of calling maths functions. To allow for infix notation, we add two underscores to the beginning and end of the function name when we define it. So for some example python code:


\begin{lstlisting}
# Python infix add function
def __add__(a, b):
    return a + b
\end{lstlisting}

We can run it by calling

\begin{lstlisting}
# Python call infix add function
    a = 1
    b = 2
    c = a + b
\end{lstlisting}

Which is infix notation. Now in this example, it may seem almost obsolete to create a function that already mimics the behaviour of what we are trying to achieve, however using this notation we are able to overwrite the existing infix notation in python, and even create new notation of any data types that we choose to create.

A simple example of this is with the fraction class. There is no inbuilt class for handling fractions in python, so we can create one and allow it to use infix notation.

If we have a fraction class that takes a numerator and denominator as an input, and have this function defined in the class, it would look as follows:


\begin{lstlisting}
# Python __add__ as part of the Fraction Class
def __add__(self, other):
        """ self + other """
        other = self._convert_to_fraction(other, 'addition')
        resulting_numerator = self.numerator * other.denominator +
                              self.denominator * other.numerator
        resulting_denominator = self.denominator * other.denominator
        return (Fraction(resulting_numerator, resulting_denominator))
\end{lstlisting}

This function finds a common denominator for the fractions and then adds the numerators together.

To call this function to add $\frac{3}{4}$ and $\frac{1}{2}$ , we would use infix notation as follows:


\begin{lstlisting}
# Python calling __add__ for two instances of the class Fraction
Fraction(3, 4) + Fraction(1, 2)
\end{lstlisting}

Which would return the correct value of $\frac{5}{4}$.

As we can see from this example, we have created a python function that can be called using infix notation, rather than the standard postfix notation.

One other point to note is that python does not handle infix notation for user defined data types very well. If we want to compute the user defined \textit{Fraction} + the Python Integer $3$, this is okay. But due to the way python has been created, we would be unable to do Integer $3$ + \textit{Fraction}. For this we need to define another function called \textit{\_\_radd\_\_}, short for right add. This allows us to still compute the infix addition, even when the user defined variable is on the right hand side of the addition sign. The \textit{\_\_radd\_\_} function would use the already created \textit{\_\_add\_\_} function, but would have its arguments swapped and the code would look as follows:

\begin{lstlisting}
# Python infix radd function
def __radd__(self, other):
        """ other + self """
        return self.__add__(other)
\end{lstlisting}

This would swap the arguments around so that the \textit{\_\_add\_\_} function is then called with the parameters in the correct position.

\clearpage
\subsection{Database Design}

Throughout this next section, I will be explaining the structure of the database I will be using, creating data tables for each of the tables in the database, create designs for the key SQL queries that will be used, and I will create entity-relationship diagrams for the database.

\subsubsection{Table Designs}
In this subsection, I will be using data tables to represent the tables that will be present in my database.

Within my database, there will be 8 tables, which are:

\begin{enumerate}
    \item Users Table
    \item Questions Table
    \item Answers Table
    \item User Answer Table
    \item Notes Table
    \item Notes Responses Table
    \item Zeta Table
    \item User Zeta Table
\end{enumerate}

In each data table, I will show the table name and the name of each of the fields in the table. For each of the fields, I will list whether it is a key of the table, it's datatype, any necessary validation using regular expressions, and some notes on the field.

With the regular expression used for validation, an item in the table will only be considered valid if the entire item itself is a match to the regex. For strings, I am limiting their size to 140 characters, such that the user will be unable to enter strings that are too long and potentially use up too much storage in the database.

\clearpage
\textbf{Users Table}

The purpose of the Users Table will be to store the login credentials for each user registered to the program. The table will store the username, email, and hashed password of each of the users. This is the table that will be referenced when a user creates an account, or goes to login to an existing account.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Users}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    User\_ID & Primary & Integer & & \\
    \hline
    Username & & String & \textbackslash w\{1,20\} & Unique Username for each user\\
    \hline
    Email & & String & .+@.+\textbackslash ..+ & \\
    \hline
    Password & & String & & A hashed version of the user's password\\
    \hline
    \end{tabular}
    \caption{Data table for the Users Table}
\end{table}

\textbf{Questions Table}

Another table in the database is the Questions Table. At points throughout the program, the user will be asked questions. These are questions that the user can either get right or wrong and they are used to check that the user is able to use the program in the right way.

The table will store, for each question, the question number the actual question itself, and the correct answer to the question.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Questions}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Queston\_ID & Primary & Integer & & \\
    \hline
    Queston\_No & & Integer & \textbackslash d+ & The number of the question\\
    \hline
    Question & & String & .\{1,140\} & Questions that is asked to the user\\
    \hline
    Answer & & String & .\{1,140\} & The correct answer to the question\\
    \hline
    \end{tabular}
    \caption{Data table for the Questions Table}
\end{table}

\clearpage

\textbf{Answers Table}

Users will be expected to give answers to the questions, throughout the program. The answers of each user will be stored in the Answers table.

Every answer will have an associated Answer\_ID, which will be used in the User Answer table to determine answer corresponds to which user. The answer field will be used to record the various different answers said by the users, and the values in Answer, will be in the form of a set, such that two members in the Answer field will not be the same. The Question\_ID field is then used to match each answer up with the question that it was answering.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Answers}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Answer\_ID & Primary & Integer & & \\
    \hline
    Answer & & String & .\{1,140\} & \\
    \hline
    Question\_ID & & Integer & & \\
    \hline
    \end{tabular}
    \caption{Data table for the Answers Table}
\end{table}

\textbf{User Answer Table}

The User Answer table will link the user's answers to them. Formatting the table this way allows for minimal data to be stored. If the answer to one of the questions is 2, and the vast majority of users answer 2, then the value 2 will only need to be stored once in the answers table, we can then use the User Answers table to link the User\_ID of everyone who answered 2, to the Answer\_ID of 2, rather than saving an answer over and over again.

This table will only have two fields, the User\_ID, and the Answer\_ID.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: User Answer}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    User\_ID & & String & & \\
    \hline
    Answer\_ID & & String & & \\
    \hline
    \end{tabular}
    \caption{Data table for the User Answer Table}
\end{table}

\clearpage
\textbf{Notes Table}

Similarly to the questions and answers that occur in the program, the user will also be able to make notes and comments on their findings.

The difference between notes and questions is that there are no wrong or right answers (or responses as I name them) for the notes, whereas the answer to a question will either be right or wrong.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Notes}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Notes\_ID & Primary & Integer & & \\
    \hline
    Note\_No & & Integer & \textbackslash d+ & The number of the note question\\
    \hline
    Question & & String & .\{1,140\} & Questions that is asked to the user\\
    \hline
    \end{tabular}
    \caption{Data table for the Questions Table}
\end{table}

\textbf{Responses Table}

The responses table will act to the Notes table in a similar way to how the Answers table has a relationship with the Question Table.

Whoever, there will of course be differences in how the tables relate to each other, how they are used, and differences in the information stored in each of the tables.

Unlike with the Questions and Answers, the Responses to the Notes will most likely by completely unique from user to user. Therefore, creating a User Responses table, similar to the User Answer table will not be necessary.

In the table will be stored each response, the Response\_ID, which will be a unique identifier for each response, the Note\_ID, which describes which note the response is for, and the User\_ID, showing which user said the response.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Responses}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Response\_ID & Primary & Integer & & \\
    \hline
    Note\_ID & & Integer & & \\
    \hline
    Response & & String & .\{1,140\} & The user's response to the posed question\\
    \hline
    User\_ID & & Integer & & \\
    \hline
    \end{tabular}
    \caption{Data table for the Questions Table}
\end{table}

\clearpage
\textbf{Zeta Table}

The zeta table will be used to store values of the zeta function. The aim of this table is to be able to store possibly hundreds of input, output pairs for the zeta function.

These input and output values will be complex numbers in the form $a+bi$, where $a$ and $b$ are two integers

The Zeta\_ID Field, will be used in the User Zeta table, to determine which users have computed which values of the zeta function.


\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.12\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.17\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Zeta}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Zeta\_ID & Primary & String & & \\
    \hline
    Input & & String & \textbackslash d+\textbackslash +\textbackslash d+i & \\
    \hline
    Output & & String & \textbackslash d+\textbackslash +\textbackslash d+i & \\
    \hline
    \end{tabular}
    \caption{Data table for the Zeta Table}
\end{table}

\textbf{User Zeta Table}

The last table in the database will be the User Zeta table. Its fields will be Zeta\_ID and User\_ID and will be used to match up users and input-output pairs that have been calculated for the zeta function.

This table will be used to calculated which users have computed which values of the riemann zeta function.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: User Zeta}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Zeta\_ID & & String & & \\
    \hline
    User\_ID & & String & & \\
    \hline
    \end{tabular}
    \caption{Data table for the User Zeta Table}
\end{table}

\subsubsection{Third Normal Form}
\subsubsection{Database-Program Connections}
% SQL
% Creating the tables
% Retrieving data from the tables
\subsubsection{Entity-Relationship Diagrams}
\clearpage

\subsection{Key Algorithms Design}
Throughout this section, I will be modelling some of the key algorithms used throughout this project. For each algorithm, I will describe how it works using structured English, represent it by using a flowchart, and then write the algorithm in Pseudocode and Python.

\subsubsection{Euclidean Algorithm}
The Euclidean Algorithm is a method for computing the greatest common divisor of two integers. The greatest common divisor is the largest number that divides into both of the numbers without a remainder. This algorithm is recursive.

It works by, first, taking in two integers $a$ and $b$. These are the numbers for which the greatest common divisor will be found. I will explain how this algorithm works through the use of an example.

Say we want to find the greatest common divisor of 45 and 10.
We would first take the largest of the two numbers, and set that equal to some multiple of the smaller number, plus some remainder.
$$45 = 10 \cdot n + r$$
Where $n$ is the multiple of the smaller number, and $r$ is the remainder.
We can then compute what the values of $n$ and $r$ are. For this example, $n = 4$ and $r = 5$.
$$45 = 10 \cdot 4 + 5$$
Say we then use this as a general equation
$$a = b \cdot n + r$$
The next step (and every other step) of the algorithm is to take the value of $b$ and move it to the left hand side of the equation, replacing the value of $a$. We then do a similar thing by replacing the value of $n$ with the value of $r$. This process is repeated until $r = 0$.

Completing this step would look as follows:
$$10 = 5 \cdot n + r$$
Then working out the values of $n$ and $r$
$$10 = 5 \cdot 2 + 0$$
And now the repeating process stops because $r=0$. We then output the value of $b$, and that is the answer for the greatest common divisor of the two numbers $a$ and $b$. So for this example, the greatest common divisor of $45$ and $10$ is $5$.

Now, lets see how this algorithm works on a larger example, where we want to work out the greatest common divisor of $300$ and $245$.
$$300 = 245 \cdot n + r$$
$$300 = 245 \cdot 1 + 55$$
$$245 = 55 \cdot n + r$$
$$245 = 55 \cdot 4 + 25$$
$$25 = 5 \cdot n + r$$
$$25 = 5 \cdot 5 + 0$$

Then our answer is the value at position $b$ in $a = b \cdot n + r$, which is $5$. So the greatest common divisor of $300$ and $245$ is 5.

Now, earlier I mentioned that we start by taking the larger of the two inputs, and place that on the left hand side of the equation, but really, the algorithm works no matter which input starts on the right of the equation. Say instead of calculating the greatest common divisor of $300$ and $245$, we want to calculate the greatest common divisor of $245$ and $300$. We would start by forming the equation:
$$245 = 300 \cdot n + r$$
And then working out the values of $n$ and $r$:
$$245 = 300 \cdot 0 + 245$$
For any set of values where the smaller input is at position $a$, we will always be left with $n = 0$ and $r = a$.

Following through with the algorithm, the next step would be:
$$300 = 245 \cdot n + r$$
This is exactly how we started the previous example. This shows that it doesn't matter which way round the two input numbers go in the algorithm, it will always compute the same number.

In other words, the greatest common divisor of $a$ and $b$, is the same as the greatest common divisor of $b$ and $a$, which intuitively makes sense.
\clearpage
Now using flowcharts, we can write the algorithm as follows:

\begin{figure}[h]
    \centering
    \caption{Euclidean Algorithm Flowchart}
    \captionsetup{justification=centering}
    \includegraphics[scale=0.6]{euclidean-algorithm-flowchart}
\end{figure}

By representing the algorithm as a flowchart, we can see that it starts of by receiving two integers $a$ and $b$ as an input, and then keeps on finding the values of $n$ and $r$ from the examples, until the value of $b$ is $0$. Implementing this as code, this looping could be done using a standard \texttt{WHILE} loop, but I think that implementing this algorithm as a recursive function would be more suitable.

Implementing this algorithm in pseudocode, it would look as follows:
\begin{algorithm}
    \caption{Euclidean Algorithm Pseudocode}
    \begin{algorithmic}
        \Function{greatest\_common\_divisor}{a, b}
            \If {$b = 0$}
                \State \Return $a$
            \Else
                \State\Return\Call{greatest\_common\_divisor}{$b$, $a$ MOD $b$}
                \Comment{recursively call the function until $b = 0$}
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

We can see from this pseudocode, the recursive nature of this algorithm.
\clearpage
Then writing the Euclidean Algorithm in Python:

\begin{lstlisting}
# Euclidean Algorithm
def greatest_common_divisor(a: int, b: int) -> int:
    if b == 0:
        return a
    else:
        # recursively call the function until b = 0
        return greatest_common_divisor(b, a % b)
\end{lstlisting}

This implementation of the Euclidean Algorithm in Python, is very efficient. Although it is recursive, and that can in some circumstances lead to a large amount of memory use - especially in Python - it would be relatively simple to unwind the stack at the end of the computation, because this function does not call any other functions and is relatively simple.


\subsubsection{Riemann Zeta Function}
One of the most important mathematical functions in this project is the Riemann Zeta Function. As mentioned in my analysis section, it can be defined as:
% \begin{align*}
    $$\zeta(s) = \sum^{\infty}_{n=1}\frac{1}{s^n}$$
Which can be rewritten as:
    $$\zeta(s) = \frac{1}{1-2^{1-s}} \sum_{n=0}^{\infty} \frac{1}{2^{n+1}} \sum_{k=0}^{n} (-1)^k \binom{n}{k} (k+1)^{-s}$$
% \end{align*}

This is just one of many of the ways that $\zeta(s)$ can be defined. The main advantages of this definition are that it is will allow inputs for any complex number $s$ (apart from when $s = 1$ for which $\zeta(s)$ is undefined), and that it is fast to compute.
\clearpage
Using flowcharts, we can write this function as follows:
\begin{figure}[h]
    \centering
    \caption{Zeta Function Flowchart}
    \captionsetup{justification=centering}
    \includegraphics[scale=0.6]{zeta-function-flowchart-two}
\end{figure}

Unfortunately, with any computational implementation of the zeta function, it would be impossible to calculate an exact output for any given input. This is due to the fact that the zeta function, be definition is the sum of an infinite series.

It would be intractable to compute every single element in the series to be able to sum it. Because the infinite sum is convergent (except for $\zeta(1)$ which cannot be calculated), we can approximate the sum by calculating a very large number of terms in the sum, instead of an infinite amount. The number of terms we calculate in the sum is a trade-off between the time it takes to compute the function, and the accuracy of our answer.

This is what the variable \texttt{Terms}, in the flowchart, is used for. Its aim is to replace the $\infty$ in the infinite loop, such that we can still compute $\zeta(s)$ to a high degree of accuracy, with the function still being relatively time efficient.

In a sense, we are changing our definition of the zeta function, so the function that we are actually calculating is this:

$$\zeta(s) \approx \frac{1}{1-2^{1-s}} \sum_{n=0}^{\texttt{Terms}} \frac{1}{2^{n+1}} \sum_{k=0}^{n} (-1)^k \binom{n}{k} (k+1)^{-s} $$

Which is a less accurate version of the zeta function, but is actually computable.

From the flowchart, we can see how the situation where $s=1$ is handled. $\zeta(1)$ is undefined, so we would be unable to calculate this. Therefore, we have to check this special case, and if $s=1$, then the function will \texttt{OUTPUT Infinity}, otherwise, it will just continue with the rest of the function.

The rest of the function, is essentially just creating two sequences and summing them. The flowchart represents this well, it allows us to visualise the looping nature of the sequences.

We can break down our formula for the approximation of $\zeta(s)$, which will make it clear how the flowchart is designed to work.

\begin{figure}[h]
    \centering
    \caption{Decomposed Zeta Function}
    \captionsetup{justification=centering}
    \includegraphics[scale=0.4]{zeta-approx-explained}
\end{figure}

From this image, we can see that:

$$\zeta(s) = \texttt{Term3} \cdot \texttt{Sum2}$$
Where:
$$\texttt{Sum2} = \sum \texttt{Term2} \cdot \texttt{Sum1}$$
Where:
$$\texttt{Sum1} = \sum \texttt{Term1}$$

Then, all that has to be done is replace the values of \texttt{Term1}, \texttt{Term2}, and \texttt{Term3} with their respective values, and that is essentially what is being calculated.

By applying decomposition to the function, we can now easily see how the flowchart works, and now how to implement this function by using pseudocode.
\clearpage
\begin{algorithm}[h]
    \caption{Zeta Function Pseudocode}
    \begin{algorithmic}
        \Function{zeta}{s}
            \State $TERMS \gets 100$
            \If{$s = 1$}
                \State \Return {$\infty$}
            \Else
                \For {$n \gets 0 \textbf { to } TERMS$}
                    \State $sum1 \gets 0$
                    \For {$k \gets 0 \textbf{ to } n+1$}
                        \State $sum2 \gets sum2 + (-1)^k \cdot \binom{n}{k} \cdot (k+1)^{-s}$
                    \EndFor
                    \State $sum1 \gets sum1 + sum2 \cdot \frac{1}{2^{n+1}}$
                \EndFor
                \State $constant \gets 1-2^{1-s}$
                \State \Return{$\frac{sum1}{constant}$}
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

For sake of readability, I have omitted creating separate variables for \texttt{Term1}, \texttt{Term2}, and \texttt{Term3}. Instead, these can just be seen by the mathematical equations present in the Pseudocode.

I much prefer this representation of the function, as it easily allows you to see how the sums are implemented alongside the terms. The use of \texttt{for} loops makes it easy to see how we have a sum being calculated inside a sum.

With pseudocode, I have just been able to write the mathematical statements for readability sake, however, when implementing this as a programming language, it could look rather messy with long maths having to be written out.
One area that would need addressing when converting this pseudocode to an actual language is with the binomial coefficient, that is $\binom{n}{k}$. I have previously mentioned this in my analysis, however:

$$\binom{n}{k} = \frac{n!}{k!(n-k)!}$$

Where:
\begin{align*}
    x! &= \prod_{a=1}^x a\\
    &= x \times (x-1) \times (x-2) \times (x-3) \times \dots \times 3 \times 2 \times 1
\end{align*}
Which is itself, the product of another series.

So when calculating the zeta function in this form, we are actually having to compute, the product of 3 series , within a series, within a series. This may not seem at all time or space efficient, but these sums are a lot easier for a computer to compute than evaluating $\zeta(s)$ by its definition that is:
$$\zeta(s) = \sum^{\infty}_{n=1} \frac{1}{n^s}$$

To implement the binomial coefficient effectively, we would not be able to use it in its factorial form - this would take too long to compute. Instead, we can define the binomial coefficient another way.

If we take our equation for the definition of the binomial coefficient, and focus on the fraction of the right hand side:
$$\binom{n}{k} = \frac{n!}{k!(n-k)!}$$
We can divide the numerator and denominator by $(n-k)!$, then we have that:
$$\binom{n}{k} = \frac{\frac{n!}{(n-k)!}}{k!}$$
Then expanding the numerator:
$$\binom{n}{k} = \frac{\frac{n(n-1)(n-2)\dots(n-k+1)(n-k)(n-k-1)(n-k-2)\dots(2)(1)}{(n-k)(n-k-1)(n-k-2)\dots(2)(1)}}{k!}$$
Notice how the denominator of the numerator exactly repeats what is above it, this means that all of these terms can cancel, such that we are left with:
$$\binom{n}{k} = \frac{n(n-1)(n-2)\dots(n-k+2)(n-k+1)}{k!}$$
Which can be rewritten as:
$$\binom{n}{k} = \frac{n^{\underline{k}}}{k!}$$
Where $n^{\underline{k}}$ is known as a falling factorial power and is defined as:

\begin{align*}
    n^{\underline{k}} &= n(n-1)(n-2) \dots (n-k+1)\\
    &= \prod_{x=1}^k (n - (x - 1))\\
    &= \prod_{x=1}^{k-1} (n - x)
\end{align*}

So looking back at how to use this to calculate the binomial coefficient, we can say that:
\begin{align*}
    \binom{n}{k} &= \frac{n!}{k!(n-k)!}\\
    &= \frac{n^{\underline{k}}}{k!}\\
    &= \frac{n(n-1)(n-2)\dots (n-(k-1))}{k(k-1)(k-2) \dots 1}\\
    &= \prod^k_{i=1} \frac{n+1-i}{i}\\
    &= \prod^{k-1}_{i=0} \frac{n-i}{i+1}
\end{align*}

We now have a function, that we can be called from inside the zeta function, in order to calculate the appropriate binomial coefficient.

Implementing the binomial coefficient function as pseudocode would look as follows:

\begin{algorithm}[ht]
    \caption{Binomial Coefficient Pseudocode}
    \begin{algorithmic}
        \Function{binom}{$n$, $k$}
            \State $b \gets 1$
            \For {$i \gets 0 \textbf { to } k$}
                \State $b = b \times \frac{n-i}{i+1}$
            \EndFor
            \State \Return $b$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

Rewriting our definition of the zeta function, with this new way of calculating the binomial coefficient, we can now say that:

$$\zeta(s) \approx \frac{1}{1-2^{1-s}} \sum_{n=0}^{\texttt{Terms}} \left( \frac{1}{2^{n+1}} \sum_{k=0}^{n} \left( (-1)^k \left(\prod^{k-1}_{i=0} \frac{n-i}{i+1} \right) (k+1)^{-s} \right) \right)$$

\clearpage
We are then able to convert both the Zeta Function Pseudocode and the Binomial Coefficient Pseudocode into Python code
\begin{lstlisting}
# Binomial Coefficient
# \binom{n}{k} = \prod^{k-1}_{i=0} \frac{n-i}{i+1}
def binom(n, k):
    v = 1
    for i in range(k):
        v *= (n - i) / (i + 1)
    return v

# Global Zeta Function
# \zeta(s) \approx \frac{1}{1-2^{1-s}} \sum_{n=0}^{\texttt{TERMS}} \left( \frac{1}{2^{n+1}} \sum_{k=0}^{n} \left( (-1)^k \left(\prod^{k-1}_{i=0} \frac{n-i}{i+1} \right) (k+1)^{-s} \right) \right)
def zeta(s, TERMS=100):
    if s == 1:
        return float('inf')
    # \sum_{n=0}^{\texttt{TERMS}} \left( \frac{1}{2^{n+1}} \sum_{k=0}^{n} \left( (-1)^k \left(\prod^{k-1}_{i=0} \frac{n-i}{i+1} \right) (k+1)^{-s} \right) \right)
    sum1 = 0
    for n in range(TERMS):
        # \sum_{k=0}^{n} \left( (-1)^k  \binom{n}{k} (k+1)^{-s} \right)
        sum2 = 0
        for k in range(n + 1):
            sum2 += (-1) ** k * binom(n, k) * (k + 1) ** (-s)
        sum1 += sum2 * (1 / (2 ** (n+1)))
    return sum1 * (1 / (1 - 2 ** (1 - s)))
\end{lstlisting}

Now we have a very efficient program that can be used to calculate any value of $\zeta(s)$.

This function will be used extensively throughout my technical solution to plot graphs, find data points and to try to help provide some proof for the Riemann Hypothesis.

\subsubsection{Circular Queue}
For parts of my project, I will require a FIFO Queue Data Structure. I will be implementing this using a circular queue. This data structure will be a class, that has a set of methods that manipulate the data in the queue. The first of these methods will be the procedure that is called to initialise the queue. When an instance of the Queue class is created, the Queue class will require an input\_queue parameter, which will have the beginning items of the queue in it. Potentially also a max\_size parameter could be used if a static data structure is wanted by the user rather than a dynamic one. When the class is initialised, a size variable will need to be created to keep track of the current length of the queue, as well as a max\_size. The queue will then have to be created with the input queue at the front, and any remaining spaces left in the queue will have to be filled in with some filler character. Variables for the front and rear pointers of the queue will then need to be created.

One of the methods used in this implementation of a Circular Queue will be the is\_full function. If the size of the queue is equal to it's maximum size, then the function will return true, otherwise it will return false.

Another method is the function is\_empty. If the size of the queue is 0, then the function will return true, otherwise it will return false.

As well as this is the enQueue method, which will take a parameter of an item. In this procedure, the item is appended to the rear of the circular queue. This procedure can only be run if the queue is not already full, if it is full, then an error will be thrown. If the queue is not full, then the element in the queue that is at the position of the rear pointer will be set equal to the item that is being enqueued. The rear pointer will then need to be incremented. The rear pointer is increased by 1, but if this value goes above the max\_size of the queue, then it will need to be set to 0. For this the mod function can be used. The variable for the size of the list will then need to be incremented by one.

Similar to this is deQueue, where an item is removed from the front of the queue and it's value is returned. This function can only be run if the queue is not already empty, otherwise an error will be thrown. The variable item will be used to hold the value of the element in the queue where it's index is equal to the front pointer. The element at this position can then be set to some blank / placeholder value. This is not necessary for computation but helps with readability when printing the queue. The front pointer will then need to be incremented by one, but be modded in a similar way to the rear queue during an enQueue. The size variable will need to be decremented by one and the item variable will be returned.

The flowcharts for each of these subroutines looks as follows:

\begin{figure}[ht]
    \centering
    \begin{subfigure}{.5\textwidth}
        \centering
        \includegraphics[width=.8\linewidth]{enQueue-circular-queue-flowchart}
        \caption{enQueue method flowchart}
    \end{subfigure}%
    \begin{subfigure}{.5\textwidth}
      \centering
      \includegraphics[width=.8\linewidth]{deQueue-circular-queue-flowchart}
        \caption{deQueue method flowchart}
    \end{subfigure}

    \begin{subfigure}{.5\textwidth}
        \centering
        \includegraphics[width=.8\linewidth]{is-full-circular-queue-flowchart}
        \caption{is\_full method flowchart}
    \end{subfigure}%
    \begin{subfigure}{.5\textwidth}
      \centering
      \includegraphics[width=.8\linewidth]{is-empty-circular-queue-flowchart}
        \caption{is\_empty method flowchart}
    \end{subfigure}
    \caption{Flowcharts for Circular Queue Methods}
\end{figure}

\clearpage

Implementing the circular queue in pseudocode looks as follows:
\algblockdefx[Name]{Class}{EndClass}%
[2][Unknown]{\textbf{class} #1(#2)}%
    {\textbf{end class}}
\algblockdefx[Name]{PubFunc}{EndPubFunc}%
[2][Unknown]{\textbf{public function} #1(#2)}%
    {\textbf{end function}}
\algblockdefx[Name]{PubProc}{EndPubProc}%
[2][Unknown]{\textbf{public prodecure} #1(#2)}%
    {\textbf{end procedure}}

\begin{algorithm}[ht]
    \caption{Circular Queue Pseudocode}
    \begin{algorithmic} [1]
        \Class[CIRCULAR QUEUE]{input\_queue, max\_size}
        \PubFunc[\_\_INIT\_\_]{self, input\_queue, max\_size}
                \State{$size \gets \textbf{ length } input\_queue$}
                \State{$front \gets 0$}
                \State{$rear \gets size$}
                \If{$size > max\_size$}
                    \State \Return Error
                \Else
                    \State{$blanks \gets list()$}
                    \State{$no\_of\_blanks \gets max\_size-size$}
                    \For {$i \gets 0 \textbf{ to } no\_of\_blanks$}
                        \State{$blanks = blanks + 'placeholder'$}
                    \EndFor
                    \State{$queue \gets input\_queue + blanks$}
                \EndIf
            \EndPubFunc\\

            \PubProc[ENQUEUE]{item}
                \If{$\text{IS\_FULL()} = True$}
                    \State {\Return Error}
                \Else
                    \State{$queue[rear] \gets item$}
                    \State{$rear \gets \textbf{ mod } rear+1, max\_size$}
                    \State{$size \gets size + 1$}
                \EndIf
            \EndPubProc

            \algstore{circular-queue}
    \end{algorithmic}
\end{algorithm}
\clearpage

\begin{algorithm}[ht]
    \caption{Circular Queue Pseudocode Continued}
    \begin{algorithmic} [1]
            \algrestore{circular-queue}

            \PubFunc[DEQUEUE]{item}
                \If{$\text{IS\_EMPTY()} = True$}
                    \State {\Return Error}
                \Else
                    \State{$item \gets queue[front]$}
                    \State{$queue[front] \gets 'placeholder'$}
                    \State{$front \gets \textbf{ mod } front+1,  max\_size$}
                    \State{$size \gets size - 1$}
                    \State \Return $item$
                \EndIf
            \EndPubFunc\\

            \PubFunc[IS\_FULL]{}
                \If{$size = max\_size$}
                    \State {\Return $True$}
                \Else
                    \State{\Return $False$}
                \EndIf
            \EndPubFunc\\

            \PubFunc[IS\_EMPTY]{}
                \If{$size = 0$}
                    \State {\Return $True$}
                \Else
                    \State{\Return $False$}
                \EndIf
            \EndPubFunc
        \EndClass
    \end{algorithmic}
\end{algorithm}

And then converting this pseudocode to python it will look as follows:

\begin{lstlisting}
class Queue:

    """
    Implementation of a circular queue

    Contains the subroutines:
        - enQueue
        - deQueue
        - is_full
        - is_empty

    """


    def __init__(self, input_queue, **kwargs):
        self.input_queue = input_queue
        self.size = len(self.input_queue)
        self.front = 0
        self.rear = len(self.input_queue)
        if 'max_size' in kwargs.keys():
            self.max_size = kwargs['max_size']
        else:
            self.max_size = len(self.input_queue)
        if self.size > self.max_size:
            raise IndexError("max_size must be greater than or equal to the size of the input queue")
        else:
            self.blanks = [False for i in range(self.max_size - self.size)]
            self.queue = self.input_queue + self.blanks

    def enQueue(self, item):
        """Appends an item to the rear of the circular queue"""
        if self.is_full():
            raise IndexError("Tried to enqueue to a full queue")
        else:
            self.queue[self.rear] = item
            self.rear = (self.rear+1) % self.max_size
            self.size += 1

    def deQueue(self):
        """Remove and return the value at the front of the circular queue"""
        if self.is_empty():
            raise IndexError("Tried to dequeue from an empty queue")
        else:
            item = self.queue[self.front]
            self.queue[self.front] = False
            self.front = (self.front+1) % self.max_size
            self.size -= 1
            return item

    def is_full(self):
        """Check if the circular queue is full"""
        return self.size == self.max_size

    def is_empty(self):
        """Check if the circular queue is empty"""
        return self.size == 0
\end{lstlisting}

\clearpage
\subsubsection{Binary Insertion Sort}
Throughout the program I will be required to sort sets of data. To sort the data, I will be using a binary insertion sort algorithm, due to it's low time and space complexity. Although not too efficient on large data sets, I should only be handling relatively small data sets during this program so the binary insertion sort should suffice for all sorting in the program.

A normal insertion sort works by having a queue which will originally contain each element in the original array. The item at the front of the queue will be removed from the queue and be placed in an array containing the elements in sorted order. When an element is taken from the queue and put in the sorted array, it is put in a position such that the elements either side of it are lower and higher than it. Once evert element has been moved from the queue to it's correct position in the sorted list, the sorted list will contain every element that was in the original array but in sorted order.

A binary insertion sort is a variation of the normal insertion sort, but instead it uses a binary search, rather than a linear search to find the position that the element will go in the sorted list. This improves the time complexity of the program from O(n) to O(log n).

In pseudocode, the algorithm for a binary insertion sort looks as follow:

\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.142]{binary-insertion-sort-flowchart}
    \caption{Binary Insertion Sort Flowchart}
\end{figure}

This algorithm written in pseudocode looks as follows:

\begin{algorithm}[ht]
    \caption{Binary Insertion Sort Pseudocode}
    \begin{algorithmic} [1]
        \Function{binary\_insertion\_sort}{data}
            \State{$queue = \text{Queue}(data)$}
            \State{$sorted \gets list()$}
            \State{$sorted \gets sorted + \text{queue.DEQUEUE()}$}
            \While{\textbf{ not } \text{queue.IS\_EMPTY()}}
                \State{$index \gets \text{binary\_search}(sorted, item)$}
                \State{$bigger \gets sorted[index:]$}
                \State{$\textbf{delete} \text{ } sorted[index:]$}
            \EndWhile
            \State{\Return $sorted$}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

And then writing the algorithm in python:

\begin{lstlisting}
def binary_insertion_sort(data, descending=False):

    """
    Sorts a list of data into ascending order using a binary insertion sort
    """


    try:
        array = list(map(float, data ))
    except ValueError:
        array = data
    queue = Queue(array)
    sorted = [queue.deQueue()]
    while not queue.is_empty():
        item = queue.deQueue()
        index = binary_search(sorted, item)
        bigger = sorted[index:]
        del sorted[index:]
        sorted.append(item)
        sorted.extend(bigger)
    if not descending:
        return sorted
    else:
        return sorted[::-1]
\end{lstlisting}

This python variation of the binary insertion sort algorithm also includes an option to return the sorted list in descending order, as well as the default ascending order.
% \subsection{Data Structure Design}

\clearpage

\subsection{File Structure}

In this section, I will showcase the full planned File Structure for the program.

\begin{itemize}
    \item \textbf{program}
    \begin{itemize}
        \item \textbf{user\_interface}
        \begin{itemize}
            \item \textbf{introduction\_ui}
            \begin{itemize}
                \item \_\_init\_\_.py
                \item Various python files for the introduction UI
            \end{itemize}
            \item \textbf{ivnestigation\_ui}
            \begin{itemize}
                \item \_\_init\_\_.py
                \item Various python files for the investigation UI
            \end{itemize}
            \item \textbf{login\_ui}
            \begin{itemize}
                \item \_\_init\_\_.py
                \item Various python files for the login UI
            \end{itemize}
            \item \textbf{notes\_ui}
            \begin{itemize}
                \item \_\_init\_\_.py
                \item Various python files for the notes UI
            \end{itemize}
            \item \textbf{summary\_ui}
            \begin{itemize}
                \item \_\_init\_\_.py
                \item Various python files for the summary UI
            \end{itemize}
            \item \textbf{tutorial\_ui}
            \begin{itemize}
                \item \_\_init\_\_.py
                \item Various python files for the tutorial UI
            \end{itemize}
            \item \_\_init\_\_.py
            \item main\_menu.py
            \item mat\_menu.py
            \item progress.py
        \end{itemize}
        \item \textbf{utils}
        \begin{itemize}
            \item \_\_init\_\_.py
            \item computational\_functions.py
            \item cryptography\_functions.py
            \item database\_functions.py
            \item email\_functions.py
            \item file\_handling.py
            \item mathematical\_functions.py
            \item number\_systems.py
            \item screen\_design.py
            \item user.py
        \end{itemize}
        \item \_\_init\_\_.py
        \item introduction\_section.py
        \item investigation\_section.py
        \item login\_section.py
        \item main\_section.py
        \item notes.py
        \item summary\_section.py
        \item tutorial\_section.py
    \end{itemize}
    \item main.py
\end{itemize}

As you can see from this file structure list, there will be many python files involved in my project. I have sufficiently modularised each file, and each directory to make imports of functions across files as streamlined as possible. main.py will be the main entry point in the program, and will run the code located in the \textbf{program} directory. The \textbf{user\_interface} directory will contain a large amount of files, however these files are somewhat unimportant when it comes to the complexity and meeting my objectives of the project. Inside the \textbf{user\_interface} directory is a directory for the UI's for each of the main sections in the program. Inside each of these directories is the code required to run the user interface for the page.

Each of these different UI sections will then it's own python file in the \textbf{program} directory, which is used to display the UI at the correct point, and allow buttons, tabs, and other interactive features to work.

The more interesting and complex code can be found in the \textbf{utils} directory. Inside this directory are key algorithms, functions, procedures, and classes that are used throughout the program.

\clearpage

\subsection{HCI and Screen Designs}
Throughout this section, I will be creating initial designs for my screen pages used throughout the program.

Each page will have a consistent structure and layout, such that it will not be confusing for a user to be able to use and navigate page.

I will not be showing the design of every page used - because they are largely similar - I will instead just be showcasing and explaining some of the designs for my most important or unique parts of the project.

\subsubsection{Generic Template}
The consistent design for my user interface will follow the following template design.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.3]{template-screen-design}
    \caption{Generic Screen Design}
\end{figure}

At the top of the page is the title. This is there to show the user which page they are on.

Below this, is the tab line. Each tab on the bar  will be a clickable button, that will take the user to a different screen. The user will be able to go through the tabs in whichever order they please, which may not necessarily be in the order they are arranged; although the program will be designed such that the next tab will follow on from the previous one.

The section with the title 'Content' will show the main part of each page. For example, if the page was showing a graph plot, it will be displayed in this section.

At the bottom of the page, are the previous and next buttons, this will display the previous and next tabs respectively. These button will allow for the user to navigate between each of the pages more easily.

\clearpage
\subsubsection{Main Menu Screen Design}

The main menu is the main entry point for the user into the program. This will be what the user first sees when they launch the program, and will display all of the possible menu options for them.

It is important that this page looks visually appealing, but is also very functional and allows for efficient traversal between screen pages.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.2]{main-menu-screen-design}
    \caption{Main Menu Screen Design}
\end{figure}

On the left hand side, is displayed a menu of all of the sections of the program that the user is able to navigate to. It is recommended that the user goes through them in the order shows, however, they will be able to navigate the sections however they please.

Selecting each menu option will show a new page for that respective section, and close the main menu page. When the user is finished with that section, they will then be sent back to the main menu screen.

If the user chooses to log in, the their username will shown on the main menu screen, as demonstrated in the figure below.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.2]{main-menu-logged-in-screen-design}
    \caption{Logged In Main Menu Screen Design}
\end{figure}

\clearpage

\subsubsection{Login Screen Design}

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.3]{login-screen-design}
    \caption{Login Screen Design}
\end{figure}

From the figure above, we can see a prototype design for the Login Page.
On the tab bar are the different options for the user. The login screen starts on the page that will be most-used, that is to be able to sign in to the program. However, the tab bar means that if a user wants to create an account, or reset their password, then they have the option there.

The user's password will not be visible when they type it in for security reasons, but in case they want to see what the have typed, then there is a show button for them.

If the user incorrectly types their username/password, then an error message will be displayed just above the submit button.

The submit button will take the user's input for their username and password, and check it against the stored values in the database. If they are incorrect, the error will be displayed, if the credentials are correct, then the user will be taken back to the main menu, and it will display their username, showing that they are logged in.

The user will then be able to go to any part of the program they wish, and have their data saved for the next time they want to use the program.

\clearpage

\subsubsection{Graph Plots Screen Design}

As part of the investigation section of the project, the user will have the opportunity to interact with various graphs. An example of how this would look is shown in the figure below.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.18]{graph-plots-screen-design}
    \caption{Graph Plot Screen Design}
\end{figure}

The graph will be animated, such that it updates in real time as the user is looking at it. The user will also be able to change input values into the graph plots.

\subsubsection{Calculator Screen Design}

Another part of the investigation section will be where the user can calculate values of the zeta function. The basic version will be where the user can enter a single input value, and an output value is calculated.

A more advanced version is where the user defines a range of value for the input, by given a start value, a stop value and a step value for the difference between the values.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.18]{zeta-function-calculator-screen-design}
    \caption{Zeta Function Calculator Screen Design}
\end{figure}

The user will then be able to store the output values from this calculator in a database. The database will contain values of zeta that every user who uses the program calculates, and each input output pair calculated will be stored with the user who found out the value, then there will be a leaderboard of who has calculated the most values for the zeta function.


\clearpage
\section{Technical Solution}

\subsection{Program Re-design}
While creating my solution to the problem, I realised that my initial design was lacking in some areas, and a lot if it needs to be updated.

\subsubsection{Database Redesign}

The first area that needed to be redesigned was the database. I realised that parts of my old design were almost obsolete and unnecessary, while my database was also not in complete third normal form. I redesigned that database, such that it now contains the following tables:

\textbf{Users Table}

The user's table is vastly unchanged from my original design. The main change is that I removed the User\_ID Field, as it was obsolete and used the Username as the primary key as it will be unique for each user. This table will store the credentials for each user who has registered an account

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Users}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Username & Primary & TEXT & \textbackslash w\{1,20\} & Unique Username for each user\\
    \hline
    Email & & TEXT & .+@.+\textbackslash ..+ & A unique email address for each user\\
    \hline
    Password & & TEXT & & A hashed version of the user's password\\
    \hline
    \end{tabular}
    \caption{Data table for the Users Table}
\end{table}

\textbf{User's Answers Table}

The User's Answers table will be used to store the answers that each user has input to the various questions that are asked throughout the program.


\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: User's Answers}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Question\_No & Primary & INTEGER & \textbackslash d+ & The number of the question that is being answered\\
    \hline
    Username & Primary & TEXT & \textbackslash w\{1,20\} ..+ & The username of the user that is answering the question\\
    \hline
    UserAnswer & & TEXT & & The user's answer to the question\\
    \hline
    \end{tabular}
    \caption{Data table for the User's Answers Table}
\end{table}

\clearpage
\textbf{Notes Table}

The Notes table will be used to store the notes that each user makes when they use the program, so that these notes can be loaded next time they log in

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Notes}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Username & Primary & TEXT & \textbackslash w\{1,20\} & The username of the user who is making the note\\
    \hline
    Section & Primary & TEXT & [a-zA-Z] & The section that the note is being made for\\
    \hline
    Text & & TEXT & & The user's note\\
    \hline
    \end{tabular}
    \caption{Data table for the Notes Table}
\end{table}

\textbf{Zeroes Table}

The zeroes table will store the input for every zeta zero calculated and saved by users

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Zeroes}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Zero\_ID & Primary & INTEGER & \textbackslash d+ & A unique ID for this zeta zero\\
    \hline
    Zero\_Real\_ Input & & REAL & \textbackslash d(\textbackslash. \textbackslash d+)? & The real part of the input for this zeta zero\\
    \hline
    Zero\_Imag\_ Input & & REAL & \textbackslash d(\textbackslash. \textbackslash d+)? & The imaginary part of the input for this zeta zero\\
    \hline
    \end{tabular}
    \caption{Data table for the Zeroes Table}
\end{table}

\clearpage
\textbf{User Zeroes Table}

The user zeroes will relate every zeta zero calculated back to the user who calculated it.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table:User Zeroes}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Zero\_ID & Primary & INTEGER & \textbackslash d+ & A unique ID for this zeta zero\\
    \hline
    Username & Primary & TEXT & \textbackslash w\{1,20\}& The user that computed this zeta zero\\
    \hline
    \end{tabular}
    \caption{Data table for the User Zeroes Table}
\end{table}


\textbf{Zeta Table}

The zeta table will contain all of the stored inputs and outputs of the zeta function.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Zeta}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Zeta\_ID & Primary & INTEGER & \textbackslash d+ & A unique ID for each input-output pair\\
    \hline
    Input\_Real & & REAL & \textbackslash d(\textbackslash. \textbackslash d+)? & Real part of the input for this value\\
    \hline
    Input\_Imag & & REAL & \textbackslash d(\textbackslash. \textbackslash d+)? & Imaginary part of the input for this value\\
    \hline
    Output\_ Real & & REAL & \textbackslash d(\textbackslash. \textbackslash d+)? & Real part of the output for this value\\
    \hline
    Output\_ Imag & & REAL & \textbackslash d(\textbackslash. \textbackslash d+)? & Imaginary part of the output for this value\\
    \hline
    \end{tabular}
    \caption{Data table for the Zeta Table}
\end{table}

\clearpage
\textbf{User Zeta Table}

The user zeroes table will relate every  zeta value calculated to the user who computed it.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: User Zeta}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Zeta\_ID & Primary & INTEGER & \textbackslash d+ & A unique ID for this zeta value\\
    \hline
    Username & Primary & TEXT & \textbackslash w{1,20}& The user that computed this value\\
    \hline
    \end{tabular}
    \caption{Data table for the User Zeta Table}
\end{table}


\textbf{Correct Answers Table}

The correct answers table lists all of the acceptable answers for the questions asked in the program.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Correct Answers}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Questions\_ No & Primary & INTEGER & \textbackslash d+ & The question that this answer is correct for\\
    \hline
    Correct \text{ } Answer & Primary & TEXT & \textbackslash w+ & A valid answer for that question\\
    \hline
    \end{tabular}
    \caption{Data table for the Correct Answers Table}
\end{table}

\textbf{Questions Table}

The questions table lists all of the questions that are asked in the program.

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.15\linewidth} | p{0.1\linewidth} | p{0.16\linewidth} | p{0.14\linewidth} | p{0.25\linewidth} | }
    \hline
    \multicolumn{5}{|c|}{\textbf{Table: Questions}}\\
    \hline
    \hline
    \textbf{Field} & \textbf{Key} & \textbf{Data Type} & \textbf{Validation} & \textbf{Notes} \\
    \hline
    Question\_ No & Primary & INTEGER & \textbackslash d+ &\\
    \hline
    Question & Primary & TEXT & \textbackslash w+ & The questions that is being asked\\
    \hline
    \end{tabular}
    \caption{Data table for the Questions Table}
\end{table}

\clearpage
\textbf{Entity Relationship Diagram}

Now that the database has been properly designed, here is the entity relationship diagram for the database, showing all of the connections between tables

\begin{figure}[h]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.17]{database-er-diagram}
    \caption{Database Entity Relationship Diagram}
\end{figure}

\textbf{Third Normal Form}

Unlike the previous database that I had designed, this database is now in third normal form. To be in third normal form, a database must meet the following criteria:

First Normal Form:
\begin{itemize}
    \item All rows must be unique
    \item Each cell must contain a single value
    \item Data must be atomic
\end{itemize}
\clearpage
Second Normal Form:
\begin{itemize}
    \item Must be of first normal form
    \item Contains no partial dependencies
\end{itemize}

Third Normal Form:
\begin{itemize}
    \item Must be of second normal form
    \item Contains no non-key dependencies
\end{itemize}

Since redesigning the database, there are now no non-key dependencies, no partial dependencies, all data is atomic, each cell only contains one value and all of the rows are unique, meaning that this database is now in third normal form. This helps throughout the creation of my technical solution, as data will be easier to change and maintain, there will be no duplication of data, meaning that data integrity is maintained, and smaller tables with fewer fields allows for faster searches.

\subsubsection{User Interface Redesign}
Although my screen designs will look the same in the technical solution as they did in my design, I have made vast changes to how these designs will be implemented and displayed throughout the program.

Each page in the GUI will have it's own file in the \textbf{user\_interface} directory. Each of these files will contain a class that is used to configure the correct GUI for that page. Then, in the \textbf{program} directory, there will be a python file for each of the different sections of the program. In each of these python files there will be a class for each page of the GUI. This class creates an instance of the class used to configure the GUI and actually displays the page. Each of these classes then inherits methods and attributes from a class for that overall section, which sets up key buttons and tabs to function properly and contains some methods that are run frequently in the different classes for each page.

These section classes then inherit methods and attributes from a main Screen class, which has some commonly run functions and procedures in it.

There are also separate files and classes that are used to display graphs, as these are displayed in the program as their own screens. There is one class for a graph that is static and one for dynamic graphs.

Below is a class diagram for the tutorial section, showing how all of these classes relate to each other.

\clearpage
\begin{figure}[ht]
    \centering
    \captionsetup{justification=centering}
    \includegraphics[scale=0.113]{tutorial-class-diagram}
    \caption{Tutorial Class Diagram}
\end{figure}
\clearpage

If we look at the investigation screen in this tutorial section, we can see that we initially have the Ui\_InvestigationTutorialScreen class; which is used to configure the GUI for this page. This class is then in instance of the InvestigationTutorial class, which displays the Investigation Tutorial Screen and contains methods used for displaying the graph and updating the display when the sliders change.

This InvestigationTutorial class then inherits and is an instance of the TutorialSection class, which contains methods that are used throughout the different classes in the tutorial section.

The TutorialSection class then inherits methods and attributes from the Screen class, which contains methods and functions that are used in screen classes throughout the program.

However, the InvestigationTutorial class also has an instance of the GraphMatPlot class, which is used to set up the graph screen for that page. The GraphMatPlot screen then inherits methods and attributes from the StaticGraphScreen class.

The StaticGraphScreen class has creates instances of the UI\_MatPlotScreen class and the MplWidget class, which together allow a new page to be created with a graph on it. The StaticGraphScreen class also inherits attributes from the Screen class.

This setup may seem overly complex for simply showing a GUI, however, it has been designed such that there is no repeated code, and each class is used for just one purpose.

\clearpage

\subsection{Full Technical Solution}

See \url{https://github.com/jackm245/Riemann-Hypothesis/} for the full write-up, or appendix A at the bottom of this document

\subsection{Code Contents Page}

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.33\linewidth} | p{0.57\linewidth} | p{0.1\linewidth} |}
    \hline
    \multicolumn{3}{|c|}{\textbf{Code Contents Page - 1}}\\
    \hline
    \hline
    \textbf{Code} & \textbf{Description} & \textbf{Pages}\\
    \hline
    main function & The main entry point to the program & \\
    \hline
    MainMenu class & Displays the main menu & \\
    \hline
    Progress class & Displays the user's progress through the program& \\
    \hline
    LoginSection class & The login system, inherited by all other login classes & \\
    \hline
    ResetPassword2 class & Allows the user to permanently change their passwords & \\
    \hline
    ResetPassword class & Screen that requires user to login before password change & \\
    \hline
    ForgottenPassword2 class & User enters verification code to prove identity & \\
    \hline
    ForgottenPassword class & Verification code sent to user's email & \\
    \hline
    SignUp class & Allows for the creation of a new user & \\
    \hline
    Login class & Allows a user to sign in to an account & \\
    \hline
    TutorialSection class & Main class for the tutorial, inherited by all other tutorial classes & \\
    \hline
    Tutorial class & Entry point to the tutorial section & \\
    \hline
    ProgramStructure class & Displays the Program Structure Tutorial Screen & \\
    \hline
    LoginTutorial class & Displays the Login Tutorial Screen & \\
    \hline
    IntroductionTutorial class & Displays the Introduction Tutorial Screen & \\
    \hline
    InvestigationTutorial class & Displays the Investigation Tutorial Screen & \\
    \hline
    GraphMatPlot class & Displays graph in the Investigation Tutorial Screen & \\
    \hline
    SummaryTutorial class & Displays the Summary Tutorial Screen & \\
    \hline
    IntroductionSection class & Main class for the introduction, inherited by all other introduction classes & \\
    \hline
    Introduction class & Entry point to the Introduction section & \\
    \hline
    HistoricalBackground class & Displays the Historical Background Screen & \\
    \hline
    \end{tabular}
    \caption{Code Contents Page - 1}
\end{table}
\clearpage

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.33\linewidth} | p{0.57\linewidth} | p{0.1\linewidth} |}
    \hline
    \multicolumn{3}{|c|}{\textbf{Code Contents Page - 2}}\\
    \hline
    \hline
    \textbf{Code} & \textbf{Description} & \textbf{Pages}\\
    \hline
    WhatIsTheRiemann \text{ }  \text{ } \text{ } Hypothesis class & Displays the What is the Riemann Hypothesis Screen & \\
    \hline
    PracticalApplications class & Displays the Practical Applications Screen & \\
    \hline
    InvestigationSection class & Main class for the investigation, inherited by all other investigation classes& \\
    \hline
    CalculateZeroes2 class & Displays the zeta zeroes that the user has calculated & \\
    \hline
    CalculateZeroes class & Asks the user how many zeta zeroes they want to calculate & \\
    \hline
    Zeroes class & Displays the zeroes screen in the investigation & \\
    \hline
    CalculatorLeaderboard class & Displays the zeroes screen in the investigation & \\
    \hline
    TableCalculator2 class & Displays the zeta values that the user calculated& \\
    \hline
    TableCalculator class & Allows the user to input values for the table calculator & \\
    \hline
    SingleCalculator class & Allows the user to calculate values of the zeta function & \\
    \hline
    Calculator class & Displays the calculator screen in the investigation section& \\
    \hline
    PrimeNumbers class & Displays the prime numbers screen in the investigation section& \\
    \hline
    ZetaApproximation \text{ } \text{ } MatPlot class & Displays a graph showing the convergent  nature of the riemann zeta function& \\
    \hline
    ZetaApproximation class & Allows the user to input a value to graph & \\
    \hline
    PrimeCountingFunction MatPlot class & Displays a graph of the prime counting function and other related functions & \\
    \hline
    PrimeCountingFunction MatPlot class & Displays a graph of the prime counting function and other related functions & \\
    \hline
    PrimeCountingFunction class & Displays the prime counting function screen & \\
    \hline
    ZetaZeroesMatPlot class & Displays a graph of the zeta zeroes & \\
    \hline
    ZetaZeroesPlot class & Displays the zeta zeroes mat plot screen & \\
    \hline
    PolarGraphMatPlot class & Displays a polar graph of the zeta function & \\
    \hline
    PolarGraph class & Asks the user for an input for the polar graph& \\
    \hline
    GraphPlot class & Entry point to the investigation section & \\
    \hline
    \end{tabular}
    \caption{Code Contents Page - 2}
\end{table}
\clearpage


\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.33\linewidth} | p{0.57\linewidth} | p{0.1\linewidth} |}
    \hline
    \multicolumn{3}{|c|}{\textbf{Code Contents Page - 3}}\\
    \hline
    \hline
    \textbf{Code} & \textbf{Description} & \textbf{Pages}\\
    \hline
    SummarySection class & Class inherited by all other classes in the summary section& \\
    \hline
    Summary class & Main entry point to the summary section & \\
    \hline
    TheoryRecap class & Displays the theory recap screen & \\
    \hline
    InvestigationResults class & Displays the investigation results screen & \\
    \hline
    Conclusion class & Displays the conclusion and \& evaluation screen & \\
    \hline
    Imapct class & Displays the impact screen & \\
    \hline
    Notes class & A class inherited by all other classes in the notes section & \\
    \hline
    TutorialNotes class & Allows the user to make notes on the tutorial & \\
    \hline
    IntroductionNotes class & Allows the user to make notes on the introduction & \\
    \hline
    InvestigationNotes class & Allows the user to make notes on the investigation & \\
    \hline
    SummaryNotes class & Allows the user to make notes on the summary & \\
    \hline
    utils directory & Contains key functions, procedures and algorithms that are used throughout the program & \\
    \hline
    binary\_search function & Searches for a target in a set of data with time complexity O(log n) & \\
    \hline
    binary\_insertion\_sort function & Sorts a set of data efficiently using a queue & \\
    \hline
    Queue class & An abstract data structure of a FIFO Queue & \\
    \hline
    Stack class & An abstract data structure of a LIFO Stack & \\
    \hline
    save\_zeta\_to\_file function & Uses the binary insertion sort and dictionaries to save data to a csv file& \\
    \hline
    change\_datatype function & Uses structural pattern matching to change the datatype of a variable, when the datatype is given as a string &\\
    \hline
    cryptography\_functions file & Contains functions used for hashing passwords &\\
    \hline
    database\_query function & A function used to easily be able to query the database &\\
    \hline
    create\_database function & Creates the database and all of its tables, populating some of the tables &\\
    \hline
    get\_id function & Uses recursion to auto increment the ID for a table in the database &\\
    \hline
    email\_functions file & Sends the verification code to the user's email if they have forgotten their password&\\
    \hline
    touch function & Uses exception handling to create a file &\\
    \hline
    remove function & Uses exception handling to remove a file &\\
    \hline
    \end{tabular}
    \caption{Code Contents Page - 3}
\end{table}
\clearpage


\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.33\linewidth} | p{0.57\linewidth} | p{0.1\linewidth} |}
    \hline
    \multicolumn{3}{|c|}{\textbf{Code Contents Page - 4}}\\
    \hline
    \hline
    \textbf{Code} & \textbf{Description} & \textbf{Pages}\\
    \hline
    ncr function & Uses iterables to compute factorials and thus the binomial coefficient &\\
    \hline
    zeta function & Uses generators to compute the riemann zeta function for complex numbers &\\
    \hline
    sieve\_of\_eratosthenes function & Uses numpy arrays to find all prime numbers up to a given limit &\\
    \hline
    integration function & Integrate a given mathematical function between two limit &\\
    \hline
    exponential\_integral \text{ } function & Calculates the exponential integral for a given input &\\
    \hline
    prime\_power\_function function & Calculates the prime power function &\\
    \hline
    Number class & Abstract data type for a given number &\\
    \hline
    Complex class & Abstract data type for complex numbers &\\
    \hline
    Screen class & Class inherited by all other GUI classes &\\
    \hline
    MplWidget class & A GUI widget that allows graphs to be displayed in the GUI &\\
    \hline
    StaticGraphScreen class & Default class for displaying static graphs. Creates an instance of MplWidget and inherits Screen class&\\
    \hline
    DynamicGraphScreen class & Default class for displaying dynamic graphs. Inherits StaticGraphScreen class& \\
    \hline
    ProgramUser class & An instance of this class is used to store the user's credentials during the runtime of the program & \\
    \hline
    user\_interface directory & An extensive directory, where each python file is the configuration for the GUI for that page & \\
    \hline
    \end{tabular}
    \caption{Code Contents Page - 4}
\end{table}


Although this is not a list of every single class and function in the program, I have included a list of all of the important and complex features. For example, in the utils directory I describe almost every class/functions due to their high significance, whereas with the user\_interface directory, there are 6 folders, 43 files and 40 classes, however all they do is configure the UI which is very repetitive and doesn't require a lot of technical programming skill, thus they have not been mentioned in this contents page.
\clearpage

\subsection{Completeness of Solution}

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.5\linewidth} | M{0.2\linewidth} | p{0.3\linewidth} |}
    \hline
    \multicolumn{3}{|c|}{\textbf{Completeness of Solution - 1}}\\
    \hline
    \hline
    \textbf{Objective} & \textbf{Achieved} & \textbf{Evidence}\\
    \hline
    1. The program will be interactive and engaging for the user & Yes  & \\
    \hline
    1.(a) There will be various questions throughout the program that the user can answer & Yes & \\
    \hline
    1.(b) The user will be able to make notes on any of the content in the program & Yes & \\
    \hline
    1. (c) The user will be able to choose what they do and where they go in the program, not forced along a single route & Yes & \\
    \hline
    1. (d) The user will be able to input their own values into various functions and graphs & Yes & \\
    \hline
    2. The user will be able to save their progress through the program via a login system & Yes & \\
    \hline
    2. (a) The login system should allow the user to: & Yes & \\
    \hline
    2. (a) i. Sign in to their account & Yes & \\
    \hline
    2. (a) ii. Create a new account & Yes & \\
    \hline
    2. (a) iii. Reset their password if they want to change it & Yes & \\
    \hline
    2. (a) iv. Reset their password if they have forgotten it & Yes & \\
    \hline
    2. (b) Multiple users will be able to make separate accounts on the system & Yes & \\
    \hline
    2. (c) The user’s data such as passwords must be saved securely & Yes & \\
    \hline
    2. (d) The user must be able to see how they have progressed throughout the program & Yes & \\
    \hline
    \end{tabular}
    \caption{Completeness of Solution Table 1}
\end{table}



\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.5\linewidth} | M{0.2\linewidth} | p{0.3\linewidth} |}
    \hline
    \multicolumn{3}{|c|}{\textbf{Completeness of Solution - 2}}\\
    \hline
    \hline
    \textbf{Objective} & \textbf{Achieved} & \textbf{Evidence}\\
    \hline
    3. The user will be given some background information about the Riemann Hypothesis such that almost anyone could feel comfortable using the program & Yes  & \\
    \hline
    3. (a) The user should be able to learn the historical background of the Riemann Hypothesis & Yes & \\
    \hline
    3. (b) The user should be able to learn what imaginary and complex numbers are & Yes & \\
    \hline
    3. (c) The user should be able to learn what the Riemann Hypothesis states & Yes & \\
    \hline
    3. (d) The user should be able to learn about the practical applications of the Riemann Hypothesis & Yes & \\
    \hline
    4. The program will allow the user to plot various graphs in order to develop their understanding of the Riemann Zeta function and allow them to learn about it & Yes & \\
    \hline
    4. (a) A polar graph of the Riemann Zeta Function & Yes & \\
    \hline
    4. (b) A graph of the prime counting function, and other related functions used to estimate it & Yes & \\
    \hline
    4. (c) A graph of the zeroes of the Riemann Zeta Function & Yes & \\
    \hline
    4. (d) A visualisation of the convergence of the infinite series in the Riemann Zeta Function & Yes & \\
    \hline
    5. The user will be able to calculate specific values of the Riemann Zeta Function & Yes & \\
    \hline
    5. (a) A single calculator, where the user inputs a complex input and receives an output & Yes & \\
    \hline
    \end{tabular}
    \caption{Completeness of Solution Table 2}
\end{table}


\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.5\linewidth} | M{0.2\linewidth} | p{0.3\linewidth} |}
    \hline
    \multicolumn{3}{|c|}{\textbf{Completeness of Solution - 3}}\\
    \hline
    \hline
    \textbf{Objective} & \textbf{Achieved} & \textbf{Evidence}\\
    \hline
    5. (b) A table calculator, where the user can calculate the zeta function for a range of input values& Yes & \\
    \hline
    5. (c) A leaderboard showing how many values of the zeta function, each user has computed & Yes & \\
    \hline
    5. (d) The program will allow the user to store these value(s) to a database and to a csv file & Yes & \\
    \hline
    6. The user will be able to calculate the zeroes of the Riemann Zeta Function & Yes & \\
    \hline
    6. (a) The user will input how many zeroes they want to calculate & Yes & \\
    \hline
    6. (b) The program will calculate these zeroes & Yes & \\
    \hline
    6. (c) The zeroes will be displayed to the user in a table & Yes & \\
    \hline
    7. The user will be able to store the data that they have collected & Yes & \\
    \hline
    7. (a) The program will include a database of multiple values and zeroes of the zeta function & Yes & \\
    \hline
    7. (a) i. The user will be able to store values of the zeta function & Yes & \\
    \hline
    7. (a) ii. The user will be able to store the non-trivial zeta zeros & Yes & \\
    \hline
    7. (a) iii. The user program will retrieve data from the database and display its contents suitably to the user & Yes & \\
    \hline
    8. The Program will have a graphical user interface & Yes & \\
    \hline
    \end{tabular}
    \caption{Completeness of Solution Table 3}
\end{table}
\clearpage
\section{Testing}
\subsubsection{Iterative Testing}
\clearpage



\subsubsection{Post-Development Testing}

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.14\linewidth} | M{0.1\linewidth} | p{0.14\linewidth} | p{0.14\linewidth} | p{0.14\linewidth} | p{0.14\linewidth} |p{0.18\linewidth} |}
    \hline
    \multicolumn{7}{|c|}{\textbf{Post-Development Test Table - 2}}\\
    \hline
    \hline
    \textbf{Objective} & \textbf{Test \#} & \textbf{Input} & \textbf{Expected Output} & \textbf{Actual Output} & \textbf{Outcome} & \textbf{Comments}\\
    \hline
    1. & & & & & & \\
    \hline
    1.(a) & & & & & & \\
    \hline
    1.(b) & & & & & & \\
    \hline
    1.(c) & & & & & & \\
    \hline
    1.(d) & & & & & & \\
    \hline
    2. & & & & & & \\
    \hline
    2.(a) & & & & & & \\
    \hline
    2.(a)i. & & & & & & \\
    \hline
    2.(a)ii. & & & & & & \\
    \hline
    2.(a)iii. & & & & & & \\
    \hline
    2.(a)iv. & & & & & & \\
    \hline
    2.(b) & & & & & & \\
    \hline
    2.(c) & & & & & & \\
    \hline
    2.(d) & & & & & & \\
    \hline
    3.(a) & & & & & & \\
    \hline
    3.(b) & & & & & & \\
    \hline
    3.(c) & & & & & & \\
    \hline
    3.(d) & & & & & & \\
    \hline
    4. & & & & & & \\
    \hline
    4.(a) & & & & & & \\
    \hline
    4.(b) & & & & & & \\
    \hline
    4.(c) & & & & & & \\
    \hline
    4.(d) & & & & & & \\
    \hline
    5. & & & & & & \\
    \hline
    5.(a) & & & & & & \\
    \hline
    5.(b) & & & & & & \\
    \hline
    5.(c) & & & & & & \\
    \hline
    5.(d) & & & & & & \\
    \hline
    \end{tabular}
    \caption{Post Development Test Table - 1}
\end{table}
\clearpage

\begin{table}[ht]
    \centering
    \begin{tabular}{ | p{0.14\linewidth} | M{0.1\linewidth} | p{0.14\linewidth} | p{0.14\linewidth} | p{0.14\linewidth} | p{0.14\linewidth} |p{0.18\linewidth} |}
    \hline
    \multicolumn{7}{|c|}{\textbf{Post-Development Test Table - 2}}\\
    \hline
    \hline
    \textbf{Objective} & \textbf{Test \#} & \textbf{Input} & \textbf{Expected Output} & \textbf{Actual Output} & \textbf{Outcome} & \textbf{Comments}\\
    \hline
    6. & & & & & & \\
    \hline
    6.(a) & & & & & & \\
    \hline
    6.(b) & & & & & & \\
    \hline
    6.(c) & & & & & & \\
    \hline
    7. & & & & & & \\
    \hline
    7.(a) & & & & & & \\
    \hline
    7.(a)i. & & & & & & \\
    \hline
    7.(a)ii. & & & & & & \\
    \hline
    7.(a)iii. & & & & & & \\
    \hline
    8. & & & & & & \\
    \hline
    \end{tabular}
    \caption{Post Development Test Table - 2}
\end{table}

One error which I discovered during my testing was to do with saving values of the zeta function to the csv file. After going back and looking at the problem, I realised that I had a logic error where the csv file was unable to have two records where the InputReal record was the same. This is due to how I chose to sort of the data. The code at the time look as such:

\begin{lstlisting}
def save_zeta_to_file(csv_values, filepath, regex, index, fieldnames):

    """
    Given a list of complex numbers, combine these with the contents of the
    file that they are going to be saved to, sort these values using the first
    real number, and save them back into the csv file
    """

    if not os.path.isfile(filepath):
        os.mknod(filepath)
    with open(filepath, 'r') as csv_file:
        csv_reader = csv.reader(csv_file)
        for row in csv_reader:
            if row != fieldnames:
                csv_values.append(list(map(str, row)))
    sorting_dict = {list(map(float,
        re.findall(regex, ','.join(row))))[index] : row for row in csv_values}
    sorted_keys = binary_insertion_sort(list(set(sorting_dict.keys())))
    sorted_values = [sorting_dict[key] for key in sorted_keys]
    with open(filepath, 'w') as csv_file:
        csv_writer = csv.writer(csv_file)
        csv_writer.writerow(fieldnames)
        for row in sorted_values:
            csv_writer.writerow(row)
\end{lstlisting}

The problems came with lines 16 and 17, which say that

\begin{lstlisting}
    sorting_dict = {list(map(float,
        re.findall(regex, ','.join(row))))[index] : row for row in csv_values}
\end{lstlisting}

This creates a dictionary with the InputReal of each record as the key, and each record as the value, for all of the records in the file. However, if two records had the same InputReal, then they would create the same key. So then when I call

\begin{lstlisting}
    sorted_keys = binary_insertion_sort(list(set(sorting_dict.keys())))
\end{lstlisting}

I am sorting the set of all of the keys. This removes duplicates. However, I have to sort the data as a set, otherwise the binary\_insertion\_sort will not work. So I need to change the data in order to eliminate any two records having the same first value. To do this, I added the number of the record onto the end of each key. This allows each record to still be sorted, and also make them unique.

With these changes, the working function now looks as follows:

\begin{lstlisting}
def save_zeta_to_file(csv_values, filepath, regex, index, fieldnames):

    """
    Given a list of complex numbers, combine these with the contents of the
    file that they are going to be saved to, sort these values using the first
    real number, and save them back into the csv file
    """

    if not os.path.isfile(filepath):
        os.mknod(filepath)
    with open(filepath, 'r') as csv_file:
        csv_reader = csv.reader(csv_file)
        for row in csv_reader:
            if row != fieldnames:
                csv_values.append(list(map(str, row)))
    sorting_dict = {float(str(list(map(float,
        re.findall(regex, ','.join(row))))[index]) + str(row_no)) : row for row_no, row in enumerate(csv_values)}
    sorted_keys = binary_insertion_sort(list(set(sorting_dict.keys())))
    sorted_values = [sorting_dict[key] for key in sorted_keys]
    with open(filepath, 'w') as csv_file:
        csv_writer = csv.writer(csv_file)
        csv_writer.writerow(fieldnames)
        for row in sorted_values:
            csv_writer.writerow(row)
\end{lstlisting}
\clearpage
\section{Evaluation}


\subsection{Objective Completion}

In this section, I will list many of the key objectives of my program, and evaluate how well I have achieved them.

\textbf{1. The program will be interactive and engaging for the user}

User input in the forms of questions, notes and inputs to functions are abundant throughout the program. I met this first objective well by adding features that allow the user to actually control what happens in a program, instead of just getting a user to click a 'next' button over and over. Steps have been taken to make this program interactive and I believe that these features make the program both interactive and engaging. This objective has been completed well.

\textbf{1. (a) There will be various questions throughout the program that the user can answer}

In total, there are 10 questions asked to the user. The user's answer is then marked correct or incorrect. And if the user is signed in, their progress is saved, such that their answer is saved and they can see which questions they have answered correctly or incorrectly. I have met this objective.


\textbf{1. (b) The user will be able to make notes on any of the content in the program}

Throughout the program, there are many buttons that the user can click on to access the notes section, so it has been made very accessible. The notes have been split into a separate page for each section, and the user can make their notes as long as they like. This objective has been completed sufficiently.


\textbf{1. (c) The user will be able to choose what they do and where they go in the program, not forced along a single route}

Although there is a sort of default linear way to go through the program using the prev and next buttons, the tab bar on each page allows the user to jump between sections and pages as they wish. Although the actual layout and organisation of the pages could have been made more straightforwards, the user is still able to access all parts of the program at any point, so I have achieved this objective.

\textbf{2. (a) The login system should allow the user to i. Sign in to their account ii. Create a new account iii. Reset their password if they want to change it iv. Reset their password if they have forgotten it}

I am very happy with how they login system turned out in my project. It is very straightforward for the user to login, create an account, or change their password. Two key elements of this that stand out to me are the input validation for the usernames, emails, and passwords - making sure that they are always of the correct type and structure; and also with the emailing of the user when they have forgotten their password - this is very neat. An improvement I could make to the login system would be to add a page or button to log out of an account. This would not be hard to implement at all (just requires updating the User instance of the ProgramUser class), as this would stop the user having to close and reopen the program every time they want to log out of their account. Overall however, the login system does meet all of the objectives and does so well.

\textbf{2. (d) The user must be able to see how they have progressed throughout the program}

The progress section in the program sufficiently completes this objective. It displays to the user which of the questions they have answered, and if they have done so successfully. This allows the user to see what they have gotten right or wrong, and also how much they actually know about the Riemann Hypothesis. If a user starts using this program knowing nothing about the Riemann Hypothesis, then reads through the introduction and uses the investigation, and is then able to answer some, if not all, of the questions, then they have made significant progress, not just through the program but of their understanding of the Riemann Hypothesis, and this is shown on the progress page. Therefore, I have achieved this objective.

\textbf{3. The user will be given some background information about the Riemann Hypothesis such that almost anyone could feel comfortable using the program}

Through the tutorial and the introduction section, the user is given sufficient explanations regarding to the historical background of the Riemann Hypothesis, what complex numbers are, what the Riemann Hypothesis is, and what the practical applications of the hypothesis are. This information is then solidified as knowledge through the questions asked in the program, showing that the user has understood what they've read and learnt. Through these pages in the introduction section, I have reached objectives 3. (a), 3. (b), 3. (c) and 3, (d), thus meeting the overall objective 3 sufficiently. However, it would help the user understand a lot more about the program if they had a more in-depth knowledge than the information that is said during the introduction. The problem is that this project is not solely about teaching people what the hypothesis is, and reading pages and pages of information about the hypothesis would more than likely not be interesting to the user - they could just go to the wikipedia page for that. Overall, I think this program has a good balance of introductory knowledge teaching while also allowing the user to actually investigate the Hypothesis.


\textbf{4. (a) A polar graph of the Riemann Hypothesis}

Overall, most of the graphs I created in the project were clear in what they showed, and allowed the user to understand further what the Riemann Hypothesis is about. However, I am especially pleased with the turn out of this graph. Going from iteration to iteration of the zeta function, eventually finding a way of computing it such that the graph appears to calculate values of the zeta function took a lot of research but definitely was worth the while. An improvement that could be made to not just this graph but also other ones is to make them more interactive for the user. This would entail, for example, the user being able to hover with the mouse over different parts of the graph, and be shown a pop-up of the input and output of that point, or having the graph change colour slightly as the imaginary input increases with time. It's small additions like this that would make the program more appealing to use and provide just that much more useful information.

\textbf{4. (d) A graph of the zeroes of the Riemann Zeta Function}

The zeroes graph was one of the trickiest parts of this project, due to the constraints when it comes to how the values are actually calculated. There is no real formula for calculating the zeroes of the Riemann Zeta Function, so the only way to find them is to try every value as an input, and find which ones give an output of zero, essentially using brute force to try and find the zeta zeroes. It's not exactly an elegant design but is unfortunately the only way of doing so. This brute force method means that the zeroes take a long time to be calculated, with only a few points plotted on the graph after 20 or so minutes of waiting. One way of speeding this up would to just get a better computer. With a more advanced CPU with more cores, larger cache storage, and a faster clock speed; I would be able to calculate many more zeta zeroes in a given period of time. It would require a supercomputer to calculate enough zeta zeroes, to a good enough accuracy to actually get any meaningful data out of it. However, with the resources that I had available I'm pleased with what I managed to come up with and did complete this objective.

\textbf{5. (b) A table calculator where the user can calculate the zeta function for a range of input values}

The table calculator I have created in my program is very efficient. Given a range of input values, it will calculate the outputs from the zeta function for the inputs, and then display then in the table. This meets the objective. However, I don't think it's as developed as it could be. Having a table of a list of inputs and outputs isn't very useful or meaningful to the user. If instead, or as well, this data was represented using a graph - possibly even one involving domain colouring - or some other way to visualise the data, it would be a lot more useful to the user than just a table of numbers. I am happy with the table calculator feature as it meets the objective well, but I believe it could be more developed.


\textbf{6. The user will be able to calculate the zeroes of the Riemann Zeta Function}

Following on from many of the points I made while evaluating objective 4. (d), the algorithm used to calculate the zeta zeroes takes a long time to run. In the case of the graph, it could be updated as new zeroes are found, but for the table as part of this objective, every zeta zero has to be calculated before the graph can be shown. This causes a relatively empty page to be displayed for a long time. Furthermore, this page is not updating itself either. This program does not utilise threads, so the program can only do one thing at a time. This means that while the zeroes are being calculated, the old page is not being redrawn, which can lead to some weird user interface bugs. To solve this issue, I could have implemented threads, such that even while the zeta zeroes are being calculated, the previous screen can still be redrawn. Overall, the zeta zeroes calculator does work in order to find the zeroes of the zeta function, but this algorithm could have been implemented better using threads to stop UI bugs.


\textbf{7. The user will be able to store the data that they have collected}

My database is extremely efficient. Having the database in third normal form means that queries to the database are very fast. Data can be stored and retrieved in an instant. Throughout many parts of the program, the user is given the opportunity to save values to the database, through just the click of a button. Whether it's values of the zeta function, or non-trivial zeroes, the user can permanently store data to the database. Using SQLite3 as the connection between the database and my program works very well, and they way I implemented querying the database though the database\_insert, database\_select, and database\_query subroutines was very neat as it didn't require any global variables (which I was contemplating using before).


\textbf{8. The Program will have a graphical user interface}

Overall, I did well making the GUI. The page designs are all kept relatively simple and minimalistic, while still displaying all of the relevant information and allowing the user to access all parts of the program. The consistent design between pages allows for easy navigation. However, the GUI is by no means perfect. One design feature I would have liked to add would be for each page to be adjustable in it's size. Currently, the screen is a fixed size. It would taken a whole deal of time and effort, and having to learn a lot about the PyQt library, but there is a way to do this using grid layouts, and spacers. Unfortunately, I was already a long way into programming my project when I discovered this, and realised that it would have been a lot of effort to recode everything, while having very minimal reward. Another feature I would have liked to have added to my GUI would be animations. Small transitions between pages or buttons showing that they have been clicked are the small details that would make the project seem more professional. Moreover, the actual programming of my GUI was not very efficient. Creating so many classes and files was not just convoluted and confusion, but just plain inefficient. Instead, I could have created some global features that were common to each page e.g, the colours, the title position, the tab bar, the buttons - and had a template class that had these by default. Then each page could inherit this class and also add whichever extra features it needs.

To conclude, I met all of my objectives well, but there were still some areas in which I feel as if I could have improved my program by adding extra features or re-designing certain parts.

\subsection{Independent Feedback}
\subsection{Evaluation of Independent Feedback}


\clearpage

\section{Appendix A - Technical Solution Source Code}
\clearpage
\section{Appendix B - Links to Resources}
\subsection{Technical Solution Source Code}
\subsection{Testing Video}
\clearpage
\nocite{*}
\printbibliography
\addcontentsline{toc}{section}{References}

\end{document}
